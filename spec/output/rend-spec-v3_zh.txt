

                     Tor集合规范-版本3

本文档指定了隐藏服务版本3协议的工作原理。这个文本是建议224-rend-spec-ng.txt。


表的内容:

    0. 隐藏服务:概述和预备。
        0.1。对以前版本的改进。
        0.2。符号和词汇
        0.3。加密的构建块
        0.4。协议构建块
        0.5。分配的继电器单元类型
        0.6。致谢
    1. 协议概述
        1.1。从10,000英尺的高空俯瞰
        1.2。更详细:命名隐藏服务[命名]
        1.3。更详细:访问控制[IMD:AC]
        1.4。更详细地说:分发隐藏的服务描述符。IMD(经销):
        1.5。更详细地说:扩展到多个主机
        1.6。更详细:与旧隐藏服务的向后兼容性
        1.7。更详细地说:保持加密密钥脱机
        1.8。更详细:加密密钥和重放抵抗
        1.9。更详细地说:一群钥匙
            1.9.1。更详细:客户端授权[客户端认证]
    2. 生成和发布隐藏的服务描述符[HSDIR]
        2.1。派生盲密钥和子凭据
        2.2。定位、上传和下载隐藏的服务描述符
            2.2.1。把时间分成期间
            2.2.2。何时发布隐藏的服务描述符[When - hsdesc]
            2.2.3。在哪里发布隐藏服务描述符[Where - hsdesc]
            2.2.4。使用时间段和srv获取/上传HS描述符
            2.2.5。过期隐藏服务描述符[到期- desc]
            2.2.6款。匿名上传和下载的url
        2.3。发布共享随机值[PUB-SHAREDRANDOM]
            2.3.1。没有共享随机值的客户端行为
            2.3.2。隐藏服务和更改共享随机值
        2.4。隐藏服务描述符:外层包装器
        2.5。隐藏服务描述符:加密格式[HS-DESC-ENC]
            2.5.1。加密第一层[hs - desc - First layer]
                2.5.1.1。第一层加密逻辑
                2.5.1.2。第一层明文格式
                2.5.1.3。客户的行为
                2.5.1.4。混淆授权客户的数量
            2.5.2。第二层加密[hs - desc -二层]
                2.5.2.1。第二层加密密钥
                2.5.2.2。第二层明文格式
            2.5.3。获取隐藏服务描述符加密密钥
    3.介绍协议[INTRO-PROTOCOL]
        3.1。注册引入点[REG_INTRO_POINT]
            3.1.1。可扩展ESTABLISH_INTRO协议。(EST_INTRO)
               3.1.1.1。Denial-of-Server国防扩展。(EST_INTRO_DOS_EXT)
            3.1.2。在遗留Tor节点上注册引入点[LEGACY_EST_INTRO]
            3.1.3。确认设立介绍点[INTRO_ESTABLISHED]
        3.2。发送一个导入e1单元到引入点。(SEND_INTRO1)
            3.2.1之上。单元格格式[FMT_INTRO1]
            3.2.2。INTRODUCE_ACK单元格格式。(INTRO_ACK)
        3.3。在隐藏服务处处理导入e2单元。(PROCESS_INTRO2)
            3.3.1。握手加密要求
            3.3.2。加密握手示例:ntor与额外数据[ntor与额外数据]
        3.4。在引入阶段进行身份验证。(INTRO-AUTH)
            3.4.1。Ed25519-based身份验证。
    4. 对接协议
        4.1。建立一个集合点[EST_REND_POINT]
        4.2。连接到会合点
            4.2.1。准备关键的扩张
        4.3。使用遗留主机作为集合点
    5. 加密客户端和主机之间的数据
    6. 洋葱地址编码[ONIONADDRESS]
    7. 开放式问题:

1。草案指出

   本文描述了Tor版本0.2.5中隐藏服务的设计和规范。x或更高版本。它是当前租房规范的替代品。txt，重写为清晰和改进的设计。

   寻找下面的字符串“TODO”:它描述了设计中的空白或不确定性。

   变更历史:

       2013-11-29:提案首号。还有一些待办事项和XXX事项。

       2014-01-04:澄清一些不清楚的部分。

       2014-01-21:纠正一个错误。

       2014-02-20:在新的更新的提案220中，将更多的内容移到修改后的证书格式中。

       2015-05-26:修正两个打字错误。


0. 隐藏服务:概述和预备。

   隐藏服务的目的是为Tor网络上基于双向流的通信提供响应匿名。与常规的Tor连接不同，在后者中，连接启动程序接收匿名，而响应程序不接收，隐藏服务尝试提供双向匿名。

   参与者:

      操作员——运行隐藏服务的人

      主机，“服务器”——操作者运行的Tor软件，提供一种隐藏的服务。

      User——联系隐藏服务的人。

      客户端——运行在用户计算机上的Tor软件

      隐藏服务目录(HSDir)——一个Tor节点，它托管来自隐藏服务主机的签名语句，以便用户可以与之联系。

      引入点——接受隐藏服务的连接请求并匿名地将这些请求转发给隐藏服务的Tor节点。

      集合点——客户端和服务器连接的Tor节点，并在它们之间中继通信。

0.1。对以前版本的改进。

   以下是对遗留隐藏服务的改进:
 a)更好的加密(用SHA3/ed25519/curve25519代替SHA1/DH/RSA1024) b)改进了目录协议，减少了对目录服务器的泄漏。改进的目录协议与更小的表面为目标攻击。更好的洋葱地址安全防范假冒。e)更可扩展的引入/会合协议。g)高级客户端授权

0.2。符号和词汇

   除非另有规定，所有的多八位整数都是大端数。

   我们以两种方式写入字节序列:

     1. 用方括号表示的两位数十六进制值序列，如[AB AD 1D EA]。

     2. 用引号括起来的一串字符，如在"Hello"中这些字符串中的字符以ascii格式编码;字符串不以null结尾，除非显式地描述为NUL结尾。

   我们可以互换使用“字节”和“八字节”这两个词。

   我们使用竖条|来表示连接。

   我们使用INT_N(val)表示以N字节为单位的无符号整数“val”的网络(big-endian)编码。例如，INT_4(1337)是[00 00
   05年39]。值被截断如下:val % (2 ^ (N * 8))。例如,
   INT_4(42)是42 % 4294967296(32位)。

0.3。加密的构建块

   本规范使用以下加密构建块:

      *一个由强熵源支持的伪随机数发生器。
        PRNG的输出在发布到网络上之前，应该始终对其进行散列处理，以避免将原始PRNG字节泄漏到网络(参见[PRNG- refs])。

      一个流密码流(iv, k)，其中iv是长度的现时值
        S_IV_LEN字节，k是长度为S_KEY_LEN字节的键。

      *一个公钥签名系统SIGN_KEYGEN()->seckey, pubkey;
        SIGN_SIGN (seckey、味精)- >团体;和SIGN_CHECK(pubkey, sig, msg) -> {"OK"， "BAD"};其中，秘钥的长度为SIGN_SECKEY_LEN字节，公钥的长度为SIGN_PUBKEY_LEN字节，签名的长度为SIGN_SIG_LEN字节。

        该签名系统还必须支持密钥盲操作，如附录[KEYBLIND]和章节[SUBCRED]所述:
        SIGN_BLIND_SECKEY (seckey,盲目)- > seckey2和
        SIGN_BLIND_PUBKEY (pubkey,盲目)- > pubkey2。

      *一个公钥协议系统“PK”，提供
        PK_KEYGEN()——> seckey pubkey;PK_VALID(pubkey) -> {"OK"， "BAD"};和PK_HANDSHAKE (seckey pubkey) - >输出;秘密密钥的长度是PK_SECKEY_LEN字节，公共密钥的长度是
        PK_PUBKEY_LEN字节，握手产生长度为PK_OUTPUT_LEN字节的输出。

      *加密哈希函数H(d)，它应该是预像和冲突抵抗。它产生长度为HASH_LEN字节的散列。

      *一个加密消息认证码MAC(key,msg)，输出长度为MAC_LEN字节。

      一个键派生函数KDF(message, n)，输出n个字节。

   首先，我建议:

      *用AES256-CTR实例化流。

      *实例化Ed25519符号和[KEYBLIND]中的盲协议。

      *用Curve25519实例化PK。

      *用SHA3-256实例化H。

      *用SHAKE-256实例化KDF。

      用H(k_len | k | m)实例化MAC(key=k, message=m)，其中k_len为htonll(len(k))。

   对于遗留的目的，我们指定与Tor引入点和集合点协议的旧版本的兼容性。这些使用
   RSA1024、DH1024、AES128和SHA1，如rend-spec.txt中所讨论的。

   在[提案220]中，所有签名不是在字符串本身上生成的，而是在那些前缀有一个可区分的值的字符串上生成的。

0.4。协议构建块

   在下面的部分中，我们需要传输Tor节点的位置和标识。所使用的链接标识格式
   在Tor协议中扩展d2单元。

         NSPEC(链接说明符的数量)[1字节]
         NSPEC时报》:
           LSTYPE(链接说明符类型)[1字节]
           LSLEN(链接说明符长度)[1字节]
           LSPEC(链接说明符)[LSLEN字节]

   链接说明符类型如tor-spec.txt中所述。每一组链接说明符必须包括[00](tcp上的tls - based, IPv4)、[02](遗留节点标识)和[03](ed25519标识键)类型的最小说明符。

   在0.4.1.1-alpha, Tor在v3洋葱服务协议链接说明符列表中包括IPv4和IPv6链接说明符。所有可用的地址都应该包括在链接说明符中，而不管Tor实际用来连接/扩展到远程中继的地址是什么。

   我们还合并了Tor的电路扩展握手，正如在Tor spec.txt中描述的CREATE2和CREATED2单元中使用的那样。在这些握手中，知道服务器公钥的客户机发送消息并从该服务器接收消息。一旦交换完成，双方就拥有了一组共享的前向安全密钥材料，并且客户端知道没有其他人共享该密钥材料，除非他们控制了与服务器的公钥相对应的密钥。

0.5。分配的继电器单元类型

   这些中继单元类型保留用于隐藏服务协议。

      32 - RELAY_COMMAND_ESTABLISH_INTRO

            从隐藏服务主机发送到介绍点;建立了引入点。讨论了[REG_INTRO_POINT]。

      33 - RELAY_COMMAND_ESTABLISH_RENDEZVOUS

            从客户端发送到集合点;创建会合点。讨论了[EST_REND_POINT]。

      34 - RELAY_COMMAND_INTRODUCE1

            从客户发送到介绍点;引入的请求。[SEND_INTRO1]中讨论

      35——RELAY_COMMAND_INTRODUCE2

            从介绍点发送到隐藏服务主机;引入的请求。格式与介绍1相同。已在[FMT_INTRO1]和[PROCESS_INTRO2]中讨论

      36——RELAY_COMMAND_RENDEZVOUS1

            从隐藏服务主机发送到集合点;尝试将主机电路连接到客户端电路。[JOIN_REND]中讨论

      37 - RELAY_COMMAND_RENDEZVOUS2

            从会合点发送到客户端;报告主机电路到客户端电路的连接。[JOIN_REND]中讨论

      38——RELAY_COMMAND_INTRO_ESTABLISHED

            从介绍点发送到隐藏服务主机;报告尝试建立导言点的状态。[INTRO_ESTABLISHED]中讨论

      39 - RELAY_COMMAND_RENDEZVOUS_ESTABLISHED

            从会合点发送到客户端;确认收到ESTABLISH_RENDEZVOUS单元格。[EST_REND_POINT]中讨论

      40——RELAY_COMMAND_INTRODUCE_ACK

            从介绍点发送给客户;确认接收到导入e1单元并报告成功/失败。
            [INTRO_ACK]中讨论

0.6。致谢

   这个设计包含了很多人的想法，包括

     克里斯托弗·贝恩斯
     丹尼尔·j·伯恩斯坦
     马修·芬克尔
     伊恩·戈德堡
     乔治•Kadianakis
     Aniket凯特,
     挚友兰格,
     罗伯特•赎金
     罗杰·Dingledine
     亚伦约翰逊,
     蒂姆·威尔逊·布朗(“teor”)，特别版(约翰·布鲁克斯)，s7r

   它是基于Tor最初由Roger设计的隐藏服务
   Dingledine, Nick Mathewson和Paul Syverson，以及多年来人们对这个设计的改进

     托拜厄斯卡姆,
     托马斯•劳特巴赫
     卡斯滕卫矛、
     亚历山德罗Preite马丁内斯,
     罗伯特•赎金
     费迪南德Rieger,
     Christoph Weingarten,
     基督教霍奇金病,

   如果没有来自研究人员的好的攻击设计，我们将无法完成这些工作

     亚历克斯·科夫
     LasseØverlier,
     伊凡Pustogarov,
     保罗Syverson
     Ralf-Philipp Weinmann,

   参见[攻击参考]。

   这些想法中有几个来自与

      基督教Grothoff
      布莱恩·华纳
      Zooko Wilcox-O赫恩,

   如果这个文档有任何意义，这要感谢编辑帮助

      马修·芬克尔
      乔治•Kadianakis
      彼得•Palfrader
      蒂姆Wilson-Brown(“teor”),

 [XXX承认在8106工作的一大群人。[XXX承认有一大群人在8244上工作。]


   如果我想念你，请原谅我;如果我也误解了你最好的想法，请原谅。


1. 协议概述

   在本节中，我们将概述隐藏的服务协议。为了简单起见，本节省略了一些细节;当我们更详细地指定协议时，这些将在下文中给出。

1.1。从10,000英尺的高空俯瞰

   一个隐藏服务主机准备通过选择几个Tor节点作为它的引入点来提供一个隐藏的服务。它构建到这些节点的电路，并告诉它们使用这些电路将介绍请求转发给它。

   一旦选择了引入点，主机将构建一组称为“隐藏服务描述符”(或者简称为“描述符”)的文档，并将它们上传到一组HSDir节点中。这些文档列出了隐藏服务的当前介绍点，并描述了如何与隐藏服务联系。

   当客户端想要连接到一个隐藏的服务时，它首先随机选择一个Tor节点作为它的“集合点”，并构建一个电路到该集合点。如果客户端没有服务的最新描述符，它会联系合适的描述符
   并请求这样一个描述符。

   然后，客户端构建一个匿名电路，指向其描述符中列出的隐藏服务的介绍点之一，并向该介绍点提供一个介绍请求，以便传递给隐藏服务。此引入请求包括目标集合点和加密握手的第一部分。

   在接收到引入请求后，隐藏的服务主机生成一个到集合点的匿名电路并完成加密握手。会合点连接两个电路，加密握手给双方一个共享密钥，并向客户端证明它确实在与隐藏的服务对话。

   一旦两个电路连接，客户端可以发送Tor中继单元到服务器。RELAY_BEGIN单元格打开流到外部进程或服务器配置的进程;RELAY_DATA单元格用于在这些流上通信数据，等等。

1.2。更详细:命名隐藏服务[命名]

   隐藏服务的名称是其长期的主身份密钥。它被编码为主机名，以32为基数编码整个密钥，包括一个版本字节和一个校验和，然后附加字符串"。洋葱”的结尾。结果是一个56个字符的域名。
 (这是对以前版本的hidden service protocol的一个改变，在以前的版本中，我们使用了一个1024位RSA密钥的80位截断的SHA1哈希。)

   这种格式中的名称与以前的名称不同，因为它们的长度不同。一个较老的名字看起来是这样的:
 unlikelynamefora。洋葱yyhws9optuwiwsns.onion

   遵循此规范的新名称可能如下所示:
 l5satjgud6gucryazcyvyvhuxhr74u6ygigiuyixe3a6ysis67ororad.onion

   请参阅[ONIONADDRESS]部分了解编码规范。

1.3。更详细:访问控制[IMD:AC]

   通过上述流程在多个点施加对隐藏服务的访问控制。此外，还可以使用隐藏服务及其客户端之间在带外交换的预共享秘密强制实施额外的客户端授权访问控制。

   访问控制的第一阶段发生在下载HS描述符时。
   具体来说，为了下载描述符，客户端必须知道使用了哪个盲签名密钥来对其进行签名。(更多关于盲键的信息，请参见下一节。)

   要了解介绍要点，客户端必须解密隐藏的服务描述符的主体。要做到这一点，客户端必须知道服务的_unblinded_公钥，这使得不知道该知识的实体无法使用描述符(例如，不知道洋葱地址的HSDirs)。

   另外，如果启用了可选的客户端授权，则使用每个授权用户的身份x25519密钥对隐藏的服务描述符进行加密，以进一步确保未授权实体无法对其解密。

   为了让引入点向服务发送一个集合请求，客户端需要使用在隐藏服务描述符中找到的每个引入点身份验证密钥。

   访问控制的最后一层发生在服务器本身，服务器可以根据请求的内容决定响应或不响应客户机的请求。此时协议是可扩展的:服务器至少要求客户机演示隐藏服务描述符加密部分的内容。如果启用了可选的客户端授权，服务可能会额外要求客户端证明预共享私钥的知识。

1.4。更详细地说:分发隐藏的服务描述符。IMD(经销):

   隐藏的服务描述符会定期地存储在不同的位置，以防止单个目录或一组目录成为删除隐藏服务的良好DoS目标。

   对于每个周期，Tor目录授权机构都同意一个协作生成的随机值。(有关如何将该价值纳入投票惯例的说明，请参阅第2.3节;生成价值在其他建议中有描述，包括[SHAREDRANDOM-REFS]。)该值与隐藏服务目录的公共标识键组合在一起，确定了每个HSDir在该时间段所生成的描述符散列环中的位置。

   每个隐藏服务的描述符根据用于签名它们的密钥被放置在环中的位置。注意，隐藏的服务描述符没有直接使用服务的公钥签名。相反，我们使用一个密钥盲系统(KEYBLIND)来为每个隐藏的服务创建一个新的密钥。任何知道隐藏服务凭据的客户端都可以在给定的时间段内派生出这些盲的签名密钥。如果没有证书，就不可能推导出盲签名密钥。

   每个描述符的主体还使用从凭据派生的密钥进行加密。

   为了避免每个服务在每个时间段开始时都生成并上传一个新的描述符的“群发”问题，每个描述符在时间段内都会根据它的盲签名密钥上线。在新密钥上线之前，最后一个时间段的密钥保持有效。

1.5。更详细地说:扩展到多个主机

   这种设计与我们当前扩展隐藏服务的方法兼容。具体来说，隐藏服务操作符可以使用onionbalance在HSDir层的多个节点之间实现高可用性。此外，运营商可以使用提案255在引入层对其隐藏服务进行负载均衡。有关这个主题和备选设计的进一步讨论，请参阅[缩放参考]。

1.6。更详细:与旧的隐藏服务协议的向后兼容性

   这种设计与rend-spec.txt中描述的隐藏服务协议的旧版本中的客户端、服务器和hsdir节点协议不兼容。另一方面，它被设计成允许使用较旧的Tor节点作为集合点和引入点。

1.7。更详细地说:保持加密密钥脱机

   在这种设计中，隐藏服务的秘密身份密钥可以离线存储。它仅用于生成盲签名键，盲签名键用于对描述符签名键进行签名。

   为了操作隐藏服务，操作员可以预先生成大量盲签名密钥和描述符签名密钥(及其证书;参见下面的[DESC-OUTER]和[HS-DESC-ENC])，以及它们对应的描述符加密密钥，并将其导出到隐藏的服务主机。

   因此，在隐藏服务被破坏的场景中，对手只能在有限的时间内模拟它(取决于预先生成的签名密钥数量)。

   重要的是不要将盲签名密钥的私有部分发送给隐藏的服务，因为攻击者可以从它派生出秘密主身份密钥。秘密盲签名密钥只能用于为描述符签名密钥创建凭据。
 (注意:虽然协议允许离线键，但在0.3.2.1-alpha中还没有实现。)

1.8。更详细:加密密钥和重放抵抗

   为了避免介绍点重播介绍请求，隐藏服务主机绝不能两次接受相同的请求。隐藏服务设计的早期版本在这里使用了经过身份验证的时间戳，但是包含当前时间视图可能会创建有问题的指纹。(更多讨论请参阅建议222)

1.9。更详细地说:一群钥匙
 [在下文中，“加密密钥对”大致是“一个你可以做Diffie-Hellman的密钥对”，“签名密钥对”大致是“一个你可以做ECDSA的密钥对”。]

   本文档中定义的公钥/私钥对:

      主(隐藏服务)标识密钥——作为隐藏服务的标识的主签名密钥对。这个键是长期的，不能单独用于签署任何东西;它只用于生成盲签名密钥，如[KEYBLIND]和[SUBCRED]中所述。公钥被编码在。洋葱”的地址根据[命名]。

      盲签名密钥——从身份密钥派生的密钥对，用于对描述符签名密钥进行签名。对于每个服务，它都会定期更改。知道由服务的公共身份密钥和可选秘密组成的“凭据”的客户端可以派生服务的公共盲身份密钥。这个键用作目录系统中类似dht的结构中的索引(参见[SUBCRED])。

      描述符签名键——用于为隐藏的服务描述符签名的键。这是通过盲签名密钥进行签名的。与盲签名密钥和主身份密钥不同，密钥的秘密部分必须由隐藏的服务主机在线存储。此密钥的公开部分包含在HS描述符的未加密部分中(参见[DESC-OUTER])。

      引入点身份验证密钥——用于标识给定引入点的隐藏服务的短期签名密钥对。新密钥对为每个引入点;它们用于在建立引入点时对隐藏服务主机发出的请求进行签名，以便知道此密钥的公共组件的客户机可以将其引入请求发送到正确的服务。任何密钥对都不会与一个以上的介绍点一起使用。(之前在rend-spec.txt中称为“服务键”)

      引入点加密密钥——通过引入点建立连接时使用的短期加密密钥对。起类似于Tor节点的洋葱键的作用。一个新的密钥对是为每个介绍点。

   本文档中定义的对称密钥:

      描述符加密密钥——对称加密密钥，用于加密隐藏的服务描述符的主体。从当前期间和隐藏的服务凭据派生。

   其他地方定义的公钥/私钥对:

      洋葱密钥——短期加密密钥对
 (节点)身份的关键

   其他地方定义的类似于对称键的东西:

      KH来自电路握手——作为Tor电路扩展握手的一部分派生的一个不可预测的值，用于将一个请求绑定到一个特定的电路。

1.9.1。更详细:客户端授权密钥[客户端认证]

   当启用客户端授权时，隐藏服务的每个授权客户端都有另外两个非对称密钥对，这些密钥对与隐藏服务共享。没有这些密钥的实体不能使用隐藏服务。在整个文档中，我们假设这些预共享密钥以安全的带外方式在隐藏服务及其客户端之间交换。

   具体而言，每个授权客户拥有:

   -用于计算解密密钥的x25519密钥对，该密钥允许客户机解密隐藏的服务描述符。看到[HS-DESC-ENC]。

   - ed25519密钥对，允许客户端计算签名，从而向隐藏服务证明客户端是被授权的。这些签名被插入到前言e1单元中，如果没有它们，就无法完成对隐藏服务的介绍。看到[INTRO-AUTH]。

   交换这些密钥的正确方法是让客户机生成密钥并将相应的公钥发送到带外的隐藏服务。进行此交换的一种更简单但不太安全的方法是让隐藏服务生成密钥对并将相应的私钥传递给其客户端。有关如何管理这些键的详细信息，请参阅[CLIENT-AUTH-MGMT]一节。
 [TODO:同时指定隐形客户端授权。]
 (注:客户端授权在0.3.5.1-alpha实现。)

2. 生成和发布隐藏的服务描述符[HSDIR]

   隐藏的服务描述符遵循与其他Tor目录对象相同的元格式。它们以匿名的方式发布到Tor服务器
   HSDir标志，HSDir=2协议版本和tor版本>= 0.3.0.8(因为这个版本修复了一个bug)。

2.1。派生盲密钥和子凭据

   在每个时间段内(参见[time - period]获取时间段的定义)，隐藏服务主机使用不同的盲私钥来签署其目录信息，客户端使用不同的盲公钥作为获取该信息的索引。

   对于一个候选的关键推导方法，见附录[KEYBLIND]。

   此外，客户端和主机为每个周期派生一个子凭据。在引入过程中，需要了解子凭据来解密每个时期的隐藏服务描述符，并使用隐藏的服务主机进行身份验证。与凭证不同的是，它在每个时期都要更改。知道子凭据，即使与盲私钥结合使用，也不能使隐藏的服务主机派生主凭据——因此，将子凭据放在隐藏的服务主机上，同时保持隐藏服务的私钥离线是安全的。

   一个时期的次级证书派生为:
 subcredential = H(“subcredential”|凭据|加密公钥)。

   在上述公式中，credential对应于:
 凭据= H(“凭据”|公开身份-密钥)
 其中公共身份密钥是隐藏服务的公共身份主密钥。

2.2。定位、上传和下载隐藏的服务描述符[HASHRING]

   为了避免攻击，隐藏服务的描述符很容易成为审查的目标，我们将它们存储在不同的目录中，并使用共享的随机值来防止这些目录在很久以前就被预测。

   哪个Tor服务器托管隐藏服务取决于:

         *当前时间段，
         *每日次级证书，
         *隐藏服务目录的公钥;
         *在每个时间段内都会变化的共享随机值，
         *一组网络范围内的网络状态一致参数。共识参数是由权威机构投票并在共识文档中发布的整数值，在dir-spec中进行描述。三、3.3节)。

   下面我们将进行更详细的解释。

2.2.1。把时间分成期间

   为了防止单一的隐藏服务目录成为敌人永久审查隐藏服务的目标，隐藏的服务描述符被上传到不同的位置，这些位置会随着时间而改变。

   “时间段”的长度由一致参数“hsdir-interval”控制，它是介于30和30之间的分钟数
   14400(10天)。默认的时间段长度是1440(一天)。

   时间周期从Unix纪元(1970年1月1日)开始，计算方法是用纪元之后的分钟数除以时间周期。然而，我们希望我们的时间周期每天开始于12:00UTC，所以我们从纪元开始的分钟数减去12*60分钟的“旋转时间偏移”，然后除以时间周期(有效地使“我们的”纪元开始于1970年1月1日12:00UTC)。

   例如:如果当前时间是2016-04-13 11:15:01 UTC，那么从epoch开始的秒数为1460546101，以及从epoch开始的分钟数
   24342435.  然后从纪元开始的时间中减去12*60分钟的“旋转时间偏移”，得到24341715。如果当前时间段长度是1440分钟，通过除法，我们看到当前时间段编号为16903。

   具体来说，时间段#16903开始于纪元后16903*1440*60 +(12*60*60)秒，在2016年04月12日12:00 UTC，结束于纪元后16904*1440*60 +(12*60*60)秒，在2016年04月13日12:00 UTC。

2.2.2。何时发布隐藏的服务描述符[When - hsdesc]

   隐藏服务定期向责任人发布它们的描述符
   HSDirs。负责的HSDirs集是按照[WHERE-HSDESC]中指定的方式确定的。

   具体来说，每次隐藏服务发布其描述符时，它还会为未来60分钟到120分钟之间的随机时间设置计时器。当计时器触发时，隐藏服务需要再次将其描述符发布到该时间段的负责HSDirs。[TODO:使用一致参数控制重新发布周期?]

2.2.2.1。重叠的描述符

   隐藏服务需要上传多个描述符，以便它们能够被具有较老或较新的共识的客户端访问。服务需要在每个即将到来的时间段开始之前将它们的描述符上传到HSDirs中，以便客户端可以随时获取它们。此外，服务应该在一段时间结束后继续上传它们的旧描述符，以便客户端可以访问它们，这些客户端仍然与前一段时间保持一致。

   因此，服务在每一点上都维护两个活动描述符。另一方面，客户端没有重叠描述符的概念，而是总是下载当前时间段和共享随机值的描述符。服务的任务是确保描述符对所有客户机都可用。请参阅[FETCHUPLOADDESC]一节了解如何实现这一点。
 [待办事项:当我们在一台主机上运行多个隐藏服务时该怎么办?]

2.2.3。在哪里发布隐藏服务描述符[Where - hsdesc]

   本节指定在任何给定时间HSDir哈希环是如何形成的。无论何时需要一个时间值(例如获取当前时间段数)，我们假设客户端和服务使用来自其最新live共识的事后有效时间。

   以下一致参数控制隐藏服务描述符的存储位置;
 hsdir_n_replicas =范围[1,16]的整数，默认值为2。hsdir_spread_fetch =范围[1,128]的整数，默认值为3。hsdir_spread_store =范围为[1,128]的整数，默认值为4。(在0.3.2.8-rc之前，默认值是3。)

   为了确定给定的隐藏服务描述符在给定时间段内存储的位置，在获得该时间段的盲公钥后，上传或下载方计算:
 为了复制1…hsdir_n_replicas: hs_index(replicanum) = H("store-at-idx" |
                                     INT_8 (replicanum) |
                                     INT_8 (period_length) |
                                     INT_8 (period_num))
 其中blinded_public_key是在[KEYBLIND]部分中指定的，而period是时间段的长度(以分钟为单位)，而periods是使用在section [time - period]中指定的当前一致的“after valid-after”来计算的。

   然后，对于当前共识中带有HSDir标志的每个节点，我们计算该节点的目录索引为:
 hsdir_index(node) = H("node-idx" | node_identity | shared_random_value |
                                 INT_8 (period_num) |
                                 INT_8 (period_length))
 其中shared_random_value是section [PUB-SHAREDRANDOM]中权限生成的共享值，node_identity是节点的ed25519身份密钥。

   最后，对于1…hsdir_n_replicas，隐藏服务主机将描述符上传到第一个hsdir_spread_store节点，这些节点的索引紧跟在hs_index(replicanum)之后。如果已经为服务的低编号副本选择了这些节点中的任何一个，那么在选择副本的hsdir_spread_store节点时，已经选择的任何节点都将被忽略(即跳过)。

   当选择要下载的HSDir时，客户端从索引之后的第一个hsdir_spread_fetch节点中随机选择。(注意，为了使系统更好地容忍消失
   HSDirs, hsdir_spread_fetch可能小于hsdir_spread_store。)
   同样，在为副本选择扩展时，来自低编号副本的节点将被忽略。

2.2.4。使用时间段和srv获取/上传HS描述符[FETCHUPLOADDESC]

   隐藏服务和客户端需要正确使用时间段(TP)和共享随机值(SRVs)来成功获取和上传描述符。此外，为了避免时钟失真的问题，客户端和服务都使用live consensus的“验证后”时间作为决定上传和获取描述符的一种方式。通过使用一致时间作为基本事实，我们尽量减少了由于系统时钟而导致的客户端和服务的不同步。在本节中，无论何时做出基于时间的决策，都假设它们是共识时间而不是系统时间。

   正如[PUB-SHAREDRANDOM]所指定的，consensuses包含两个共享的随机值(当前值和前一个)。隐藏服务和客户端被要求将这些共享的随机值与描述符时间段匹配，并在获取/上传描述符时使用正确的SRV。本节试图精确地说明这是如何工作的。

   让我们从系统的演示开始:
 +------------------------------------------------------------------+ |                                                                  | | 00:00 12:00 00:00 12:00 00:00 | | SRV # 1 TP # 1 SRV # 2 TP # 2 SRV # 3 TP # 3   | |                                                                  | |  $==========|-----------$===========|-----------$===========|    | |                                                                  | |                                                  | +------------------------------------------------------------------+

                                      图例:[TP#1 =时间段#1][SRV#1 =共享随机值#1]["$" =描述符旋转力矩]

2.2.4.1。获取描述符的客户端行为[CLIENTFETCH]

   下面是客户端如何使用TPs和SRVs获取描述符:

   客户端总是以同步他们的TP和SRV为目标，所以他们总是想要使用TP#N和SRV#N:为了实现这个wrt时间段，客户端在获取描述符时总是使用当前时间段。现在关于电脑,如果客户是在时间领域新时期和新电脑之间(即段用“-”)它使用当前电脑,如果客户是在段之间新的电脑和新的时期(即段用“=”),它使用前面的深水。

   例子:
 +------------------------------------------------------------------+ |                                                                  | | 00:00 12:00 00:00 12:00 00:00 | | SRV # 1 TP # 1 SRV # 2 TP # 2 SRV # 3 TP # 3   | |                                                                  | |  $==========|-----------$===========|-----------$===========|    | |              ^           ^                                       | |              C1C2                                       | +------------------------------------------------------------------+

   如果客户端(C1)在13:00就在TP#1之后，那么它将使用TP#1和
   SRV#1用于获取描述符。另外，如果客户端(C2)在SRV#2之后的01:00，它仍然会使用TP#1和SRV#1。

2.2.4.2。上传描述符的服务行为[SERVICEUPLOAD]

   如上所述，服务在任何时候都维护两个活动描述符。我们将其称为“第一”和“第二”服务描述符。每当服务在经过下一个SRV计算时间后收到valid_after一致意见时，它们就会轮换它们的描述符。它们通过丢弃第一个描述符、将第二个描述符放到第一个描述符以及使用最新数据重新构建第二个描述符来轮换它们的描述符。

   像客户机这样的服务也使用了不同的逻辑来根据上面图中的位置选择SRV和TP值。其逻辑如下:

2.2.4.2.1。第一个描述符上传逻辑[FIRSTDESCUPLOAD]

   下面是上传它的第一个描述符的服务逻辑:

   当一个服务之间的时间部分新时期新电脑(即段用“-”),它使用前面的时间和以前的SRV上传它的第一个描述符:这是为了替客户有一个共识,仍在前面的时间。

   例子:考虑在上面的例子中，服务是在13:00就在TP#1之后。它将使用TP#0和srv# 0上传它的第一个描述符。
   因此，如果客户端仍然有11:00共识，它将能够根据上面的客户端逻辑访问它。

   现在如果一个服务时间片段之间的新的电脑和新的时期(即段用“=”)它使用当前时间和以前的SRV首次描述符:这是为了覆盖客户提供一个最新的共识在同一时期内作为服务。

   例子:
 +------------------------------------------------------------------+ |                                                                  | | 00:00 12:00 00:00 12:00 00:00 | | SRV # 1 TP # 1 SRV # 2 TP # 2 SRV # 3 TP # 3   | |                                                                  | |  $==========|-----------$===========|-----------$===========|    | |                          ^                                       | |年代                                        | +------------------------------------------------------------------+

   考虑到服务是在SRV#2之后的01:00:它将使用TP#1和SRV#1上传它的第一个描述符。

2.2.4.2.2。第二描述符上传逻辑[SECONDDESCUPLOAD]

   下面是上传第二个描述符的服务逻辑:

   当一个服务之间的时间部分新时期新电脑(即段用“-”),它使用当前时间和当前SRV上传第二个描述符:这是为了替客户有最新的共识的TP服务。

   例子:考虑到在上面的例子中，服务在13:00点就在TP#1之后:它将使用TP#1和SRV#1上传它的第二个描述符。

   现在如果一个服务时间片段之间的新的电脑和新的时期(即段用“=”)它使用下一个时间段和当前的电脑,第二个描述符:这是为了覆盖客户用新共识比服务(在接下来的时期)。

   例子:
 +------------------------------------------------------------------+ |                                                                  | | 00:00 12:00 00:00 12:00 00:00 | | SRV # 1 TP # 1 SRV # 2 TP # 2 SRV # 3 TP # 3   | |                                                                  | |  $==========|-----------$===========|-----------$===========|    | |                          ^                                       | |年代                                        | +------------------------------------------------------------------+

   考虑到服务是在SRV#2之后的01:00:它将使用TP#2和SRV#2上传它的第二个描述符。

2.2.5。过期隐藏服务描述符[到期- desc]

   隐藏服务将描述符的“描述符生命周期”字段设置为180分钟(3小时)。通过按[WHEN-HSDESC]中指定的方式定期重新发布它们的描述符，隐藏服务确保它们的描述符在HSDir缓存中保持有效。

   只要包括这些介绍点在内的描述符有效，隐藏服务还必须保持它们的介绍回路存在(即使是在时间周期改变之后)。

2.2.6款。匿名上传和下载的url

   隐藏服务描述符符合本规范上传一个HTTP POST请求的URL / tor /海关/ <版本> /发布相对于隐藏服务目录的根,并下载一个HTTP GET请求的URL / tor /海关/ <版本> / < z >, < z >是一个隐藏服务base64编码的盲公钥和<版本>是“3”的协议版本。

   这些请求必须以匿名的方式在不用于任何其他目的的电路上发出。

2.2.7。洋葱地址的客户端验证

   当Tor客户端从用户那里接收到一个prop224洋葱地址时，它将被调用
   在尝试连接或获取它的描述符之前，必须首先验证洋葱地址。如果验证失败，客户端必须拒绝连接。

   作为地址验证的一部分，Tor客户端应该检查底层ed25519键是否有一个扭转组件。如果Tor接受带有扭转组件的ed25519键，攻击者就可以为一个ed25519键创建多个等效的洋葱地址，这将映射到同一个服务。我们想避免这种情况，因为它可能导致钓鱼攻击和令人吃惊的行为(例如，想象一个浏览器插件阻止洋葱地址，但可以绕过一个等效的洋葱地址扭转组件)。

   客户机检测这种欺诈地址的正确方法(这种情况只会恶意发生，而不会自然发生)是从onion地址中提取ed25519公钥，并将其乘以ed25519组顺序，确保结果是ed25519身份元素。欲知详情，请参阅[tor- refs]。

2.3。发布共享随机值[PUB-SHAREDRANDOM]

   为了限制HSDir上传位置的可预测性，我们的设计依赖于一个共享随机值(SRV)，它不能提前预测，也不能被攻击者影响太大。当局必须运行一个协议，以在每个hsdir期间至少生成一次这样的值。这里我们描述他们是如何发布这些价值的;它们用于生成它们的过程可以独立于本规范的其余部分进行更改。更多信息请参见[SHAREDRANDOM-REFS]。

   根据提案250，我们在共识基础上增加了两条新路线:
 “shared- lang - before - VALUE”SP num_reveal SP VALUE NL“shared- lang -current- VALUE”SP num_reveal SP VALUE NL

2.3.1。没有共享随机值的客户端行为

   如果之前或当前的共享随机值不能在一致中找到，那么Tor客户端和服务需要在选择HSDirs时生成它们自己的随机值。

   要做到这一点，Tor客户端和服务使用:

     SRV = H("shared- random_disaster " | INT_8(周期长度))
 其中，周期长度是以分钟为单位的时间段长度，而周期num则按照[time - period]中指定的共享随机值计算，该值最初无法找到。

2.3.2。隐藏服务和更改共享随机值

   从理论上讲，由于目录权限离线或行为不当，共享随机值可能会在一段时间内改变或消失。

   为了避免在这种罕见的事件中出现客户机可达性问题，隐藏服务应该使用新的共享随机值来找到新的负责HSDirs并将它们的描述符上传到那里。

   他们上传描述符需要多长时间?

2.4。隐藏服务描述符:外层包装器

   隐藏服务描述符的格式如下，使用来自dir-spec.txt的元格式。
 SP版本号NL
 (一开始，就一次。)

       版本号是一个32位无符号整数，指示描述符的版本。目前的版本是“3”。
 "描述人的一生" SP
 (完全一次)

       描述符的生命周期，以分钟为单位。一个HSDir应该使隐藏服务描述符在上传后至少在生命分钟内过期。

       LifetimeMinutes字段可以取30到720(12小时)之间的值。
 “描述符签名-密钥证书”NL证书
 (一次。)

       “certificate”字段包含一个格式为提案220的证书，包装为“——BEGIN ED25519 CERT——”。证书用盲公钥对短期描述符签名密钥进行交叉认证。证书类型必须是[08]，盲公钥必须作为签名密钥扩展提供。
 “修正计数器”SP整数NL
 (一次。)

       描述符的修订号。如果一个HSDir接收到一个它已经有描述符的键的第二个描述符，那么它应该保留该描述符并使用更高的修正计数器提供该描述符。
 (检查单调递增的修正计数器值可以防止攻击者用旧版本的副本替换由给定密钥签名的新描述符。)
 “superencrypted”问加密字符串
 (一次。)

       一种加密的blob，其格式在下面的[HS-DESC-ENC]中讨论。该blob是用base64编码的，并包含在——BEGIN消息——和中
       ——信息——包装结束。(结果文档并不以换行符结束。)
 “签名”SP签名NL
 (只有一次，结束了。)

       以前所有字段的签名，使用描述符-签名-证书行中的签名键，前缀为字符串“Tor onion service descriptor sig v3”。我们使用一个单独的密钥进行签名，这样隐藏的服务主机就不需要拥有它的私有盲密钥。

   HSDirs接受最多50k字节的隐藏服务描述符(还应该引入一个一致的参数来控制这个值)。

2.5。隐藏服务描述符:加密格式[HS-DESC-ENC]

   隐藏的服务描述符由两层加密保护。
   客户端需要对这两层解密，以连接到隐藏的服务。

   第一层加密提供对不知道隐藏服务公钥的实体(例如HSDirs)的机密性，而第二层加密只在启用客户机授权时有用，并保护不拥有有效客户机凭据的实体。

2.5.1。加密第一层[hs - desc - First layer]

   HS描述符加密的第一层旨在保护描述符的机密性，防止实体不知道隐藏服务的公开身份密钥。

2.5.1.1。第一层加密逻辑

   第一层加密的加密密钥和格式按照[hs - desc - encryp- keys]中指定的方式生成，带有自定义参数:

     SECRET_DATA = blinded-public-key
     STRING_CONSTANT = " hsdir-superencrypted-data "

   [hs - desc - encryp- keys]中的加密方案使用从公共身份密钥派生的服务凭据(参见[SUBCRED])来确保只有知道公共身份密钥的实体才能解密第一个描述符层。

   密文放在描述符的“超加密”字段上。

   在加密之前，明文将用NUL字节填充到10k字节的最接近倍数。

2.5.1.2。第一层明文格式

   在客户端解密第一层加密之后，他们需要解析明文以得到包含在“encrypted”字段中的第二层密文。

   如果启用了客户端认证，隐藏服务将生成一个新的descriptor_cookie密钥(32个随机字节)，并使用每个授权客户端的身份x25519密钥加密它。授权的客户端可以使用描述符cookie来解密第二层加密。我们的加密方案要求隐藏服务也为每个新的描述符生成一个临时的x25519密钥对。

   如果客户端认证被禁用，则在下面的每个字段中放置虚假数据，以混淆是否启用了客户端授权。

   下面是所有支持的字段:
 “desc- authtype”SP类型NL
 (完全一次)

      此字段包含用于保护描述符的授权类型。唯一可识别的类型是“x25519”，并指定本节中描述的加密方案。

      如果禁用了客户端授权，这里的值应该是“x25519”。
 "desc-auth-ephemeral-key" SP键NL
 (完全一次)

      该字段包含一个临时的x25519公钥，该公钥由隐藏服务生成，使用base64编码。该密钥由下面的加密方案使用。

      如果禁用了客户机授权，那么这里的值应该是一个未使用的新x25519 pubkey。
 “auth-client”SP客户端id SP iv SP加密cookie
 (至少一次)

      当启用客户端授权时，隐藏服务将为其每个授权客户端插入“auth-client”行。如果禁用了客户机授权，那么这里的字段可以用适当大小的随机数据填充(‘client-id’为8字节，‘iv’为16字节，‘encrypted-cookie’为16字节，都是用base64编码的)。

      当启用客户机授权时，每个“auth-client”行都包含加密到每个客户机的描述符cookie。我们假设每个授权客户端都拥有一个预共享的x25519密钥对，用于解密描述符cookie。

      我们现在描述描述符cookie加密方案。以下是相关的关键:
 client_x =授权客户端的私有x25519密钥client_x =授权客户端的公共x25519密钥hs_y =隐藏服务的临时x25519密钥对的私钥hs_y =隐藏服务的临时x25519密钥对的公钥descriptor_cookie =用于加密描述符的描述符cookie

      隐藏服务的计算结果如下:

          SECRET_SEED = x25519(hs_y, client_X)
          KEYS = KDF(subcredential | SECRET_SEED, 40)
          客户端id =首先8字节的键
          COOKIE-KEY =密钥的最后32字节

      下面是对“auth-client”行中字段的描述:

      -“客户端id”字段是上面使用base64编码的客户端id。

      -“iv”字段是用base64编码的16个随机字节。

      “encrypated -cookie”字段包含描述符cookie密文，它是用base64编码的:encrypated -cookie = STREAM(iv, cookie - key) XOR descriptor_cookie

      有关如何解密描述符cookie的客户端逻辑，请参阅[第一层客户端行为]一节。
 “加密”问加密字符串
 (完全一次)

      包含第二层密文的加密blob，其格式在下面的[hs - desc -二层]中讨论。该blob是用base64编码的，并包含在开始消息和结束消息包装器中。

2.5.1.3。客户行为[FIRST-LAYER-CLIENT-BEHAVIOR]

    这个阶段客户端的目标是解密[hs - desc -二层]中描述的“加密的”字段。

    如果启用了客户端授权，授权客户端需要提取描述符cookie来继续对第二层进行解密，如下所示:

    授权客户端解析加密描述符的第一层，从“desc-auth-ephemeral-key”中提取临时密钥并进行计算
    如上一节所述，客户端id和COOKIE-KEY使用它们的x25519私钥。然后，客户机使用客户机id查找正确的“auth-client”字段，该字段包含描述符cookie的密文。然后客户端使用COOKIE-KEY和iv解密descriptor_cookie，后者用于解密描述符加密的第二层，如[hs - desc - second layer]中所述。

2.5.1.4。隐藏客户端授权数据

    隐藏服务应该避免泄露是否启用了客户机授权，或者有多少授权客户机。

    因此，即使禁用了客户端授权，隐藏服务也会向描述符中添加假的“desc- authc -type”、“desc- auc -ephemeral-key”和“auc -client”行，如[HS-DESC-FIRST-LAYER]中所述。

    隐藏服务还通过在描述符中添加假的“auth-client”条目来避免泄露授权客户端的数量。具体地说，描述符总是包含许多授权客户端，如果需要的话，通过添加假的“auth-client”条目，这些授权客户端是16的倍数。[XXX考虑16值的随机化]

    客户端必须接受具有任意数量的“auth-client”行的描述符，只要总描述符大小不超过50k的最大限制(也由consensus参数控制)。

2.5.2。第二层加密[hs - desc -二层]

   描述符加密的第二层设计用于保护描述符不受未授权客户端的机密性。如果启用了客户机授权，则使用descriptor_cookie对其进行加密，并包含连接到隐藏服务所需的信息，如它的介绍点列表。

   如果禁用了客户机授权，那么HS加密的第二层并不提供任何额外的安全性，但仍然使用。

2.5.2.1。第二层加密密钥

   第二层加密的加密密钥和格式按照[hs - desc - encryp- keys]中指定的方式生成，自定义参数如下:

     SECRET_DATA = blinded-公钥| descriptor_cookie
     STRING_CONSTANT = " hsdir-encrypted-data "

   如果客户端授权被禁用，'descriptor_cookie'字段将保留为空。

   密文放在描述符的“加密”字段上。

2.5.2.2。第二层明文格式

   在解密第二层密文后，客户端可以最终了解到引子点列表等。明文有以下格式:
 "create2-format " SP格式
 (完全一次)

      一个空格分隔的整数列表，表示服务器识别的CREATE2单元格格式的数字。必须至少包括tor . spec.txt中描述的ntor。请参阅tor-spec第5.1节获取可识别的握手类型列表。
 “introauth -required”SP类型NL
 (最多一次)

      以空格分隔的导入层身份验证类型列表;更多信息请参见[介绍-认证]部分。不支持至少其中一种身份验证类型的客户机将无法与主机联系。可以识别的类型是:'password'和'ed25519'。
 “single-onion-service”
 [无或最多一次]

      如果存在，这一行表示该服务是单个洋葱
      服务(有关该类型服务的更多细节，请参阅prop260)。这个字段是在0.3.0中引入的，这意味着0.2.9服务不包含这个字段。

     然后是零个或多个引入点，如下所示(可接受的值参见下面的[NUM_INTRO_POINT]部分):
 “引入点”SP链接说明符NL
 【在导言部分开始时每个导言点对应一次】

          链接说明符是以构建块中描述的格式对链接说明符块进行base64编码的。

          在0.4.1.1-alpha中，服务在描述符中包括IPv4和IPv6链接说明符。所有可用的地址都应该包含在描述符中，而不管洋葱服务实际用于连接/扩展到介绍点的地址是什么。

          客户端不应该拒绝任何LSTYPE字段，它不识别;相反，它应该在扩展请求到介绍点时逐字使用它们。

          客户端可以对描述符中的链接说明符执行基本的有效性检查。这些检查不应泄漏有关客户端版本、配置或一致意见的详细信息。(参见3.3了解服务链接说明符处理。)
 "洋葱键" SP "ntor" SP键NL
 [每个介绍点恰好一次]

          这个密钥是一个base64编码的curve25519公钥，它是介绍点Tor节点的洋葱密钥，在客户端扩展到它时用于ntor握手。
 “auth-key”证书
 [每个介绍点恰好一次]

          该证书是包在“建议书220”中的证书
          ED25519 CERT——“使用描述符签名密钥交叉验证引入点身份验证密钥。引入点身份验证密钥包含在强制签名密钥扩展中。证书类型必须是[09]。
 "enc-key" SP "ntor" SP key NL
 [每个介绍点恰好一次]

          该密钥是一个使用base64编码的curve25519公钥，用于加密到服务的引入请求。
 "enc-key-cert" NL证书
 [每个介绍点恰好一次]

          使用描述符签名密钥对加密密钥进行交叉认证。

          “ntor”键,证书是一个提案220证书裹着”——开始ED25519 CERT——“盔甲,交叉证明描述符签名密钥与ED25519相当于curve25519公共加密密钥派生的使用过程中建议228附录a证书类型必须[0 b],和签名密钥扩展是强制性的。
 "遗产钥匙" NL钥匙NL
 [每个介绍点不设或最多不设一次]

          密钥是一个用PEM格式编码的ASN.1 RSA公钥，用于[LEGACY_EST_INTRO]中描述的遗留引入点。

          只有当引入点仅支持<= 0.2.9的遗留协议(v2)或协议版本值为“HSIntro 3”时，该字段才会出现。
 “遗产key-cert”NL证书
 [每个介绍点不设或最多不设一次]

          如果“遗产钥匙”存在，必须在场。

          该证书是一个220 RSA->格式的交叉证书，包装在“-BEGIN CROSSCERT-”铠甲中，使用描述符签名密钥交叉验证在“遗产密钥”中找到的RSA公钥。

   为了与描述符格式的未来修订兼容，客户端应该忽略描述符中未识别的行。
   允许使用其他加密和认证密钥格式;客户应该忽略他们不认识的。

   成功提取隐藏服务引入点的客户端可以使用[INTRO-PROTOCOL]中指定的引入协议进行操作。

2.5.3。获取隐藏服务描述符加密密钥

   在本节中，我们将介绍隐藏服务描述符的通用加密格式。我们在两个加密层中使用相同的加密格式，因此引入了两个自定义参数SECRET_DATA和
   STRING_CONSTANT在不同的层之间变化。

   secret _data参数指定在生成加密密钥期间使用的秘密数据，而STRING_CONSTANT只是作为KDF的一部分使用的字符串常量。

   这里是关键的生成逻辑:

       SALT =从H开始的16个字节(随机)，每次我们回调描述符时都会发生变化，即使描述符的内容没有改变。(这样我们就不会泄漏介绍点列表等是否发生了变化)
 secret_input = SECRET_DATA | subcredential | INT_8(revision_counter)
 keys = KDF(secret_input | salt | STRING_CONSTANT, S_KEY_LEN + S_IV_LEN + MAC_KEY_LEN)

       密钥的首个S_KEY_LEN字节
       SECRET_IV =下一个S_IV_LEN字节的键
       MAC_KEY =最后的MAC_KEY_LEN密钥字节

   加密数据的格式为:

       盐散列的随机字节以上[16字节]
       加密密文[变量]
       以上两个字段的MAC D_MAC[32字节]

   最终的加密格式是ENCRYPTED = STREAM(SECRET_IV,SECRET_KEY) XOR明文。

   其中D_MAC = H(mac_key_len | MAC_KEY | salt_len | SALT |加密)和mac_key_len = htonll(len(MAC_KEY))和salt_len = htonll(len(SALT))。

2.5.4。介绍点数量[NUM_INTRO_POINT]

   本节定义了一个隐藏服务描述符可以有多少引入点，默认情况下的最小引入点和最大引入点:

      最小值:0 -默认值:3 -最大值:20

   值为0意味着服务仍然是活动的，但此时不希望任何客户端到达该服务。注意，随着引入点的增加，描述符的大小会显著增加。

   将最大值设置为20的原因是为OnionBalance这样的工具提供足够的可伸缩性，使其能够平衡多达120台服务器(20 x 6)的负载
   也是为了使描述符的大小不会因用户定义的值过大而淹没隐藏的服务目录。

3.介绍协议[INTRO-PROTOCOL]

   引入协议分三个步骤进行。

   首先，一个隐藏的服务主机建立一个匿名电路到一个Tor节点，并注册该电路作为一个引入点。

   单洋葱服务试图建立一个非匿名单跳电路，但使用匿名三跳电路，如果:

     *介绍点位于一个被配置为不能通过直接连接到达的地址上，或者
     *通过单跳电路连接导入点的初次尝试失败，他们正在重新尝试导入点连接。
 [在'First'之后和'Second'之前，隐藏服务发布它的引入点和关联的键，客户端按照上面[HSDIR]部分所述获取它们。]

   其次，客户端构建一个匿名电路到引入点，并发送一个引入请求。

   第三，引入点沿着引入电路将引入请求传递给隐藏服务主机，并向客户端承认引入请求。

3.1。注册引入点[REG_INTRO_POINT]

3.1.1。可扩展ESTABLISH_INTRO协议。(EST_INTRO)

   当隐藏服务建立一个新的引入点时，它发送一个ESTABLISH_INTRO单元格，包含以下内容:

     AUTH_KEY_TYPE(1个字节)
     AUTH_KEY_LEN(2字节)
     AUTH_KEY          [ AUTH_KEY_LEN字节)
     N_EXTENSIONS(1个字节)
     N_EXTENSIONS时报》:
        EXT_FIELD_TYPE(1个字节)
        EXT_FIELD_LEN(1个字节)
        EXT_FIELD (EXT_FIELD_LEN字节)
     HANDSHAKE_AUTH (MAC_LEN字节)
     SIG_LEN           [ 2字节)
     团体               [ SIG_LEN字节)

   AUTH_KEY_TYPE字段指示引入点身份验证密钥的类型和要使用的MAC的类型
   HANDSHAKE_AUTH。公认的类型有:
 [00, 01]——为遗留引入单元保留;请参见下面的[LEGACY_EST_INTRO][02]—Ed25519;sha3 - 256。

   AUTH_KEY_LEN字段决定AUTH_KEY字段的长度。AUTH_KEY字段包含公共引入点身份验证密钥。

   EXT_FIELD_TYPE、EXT_FIELD_LEN和EXT_FIELD条目被保留给引入协议的未来扩展。必须忽略具有无法识别的EXT_FIELD_TYPE值的扩展名。

   HANDSHAKE_AUTH字段包含单元中所有早期字段的MAC，使用在电路扩展协议期间生成的共享单电路材料(“KH”)作为其密钥;参见tor-spec.txt章节5.2，“设置电路键”。它可以防止重播
   ESTABLISH_INTRO细胞。

   SIG_LEN是签名的长度。

   SIG是单元格的所有内容的一个签名，使用AUTH_KEY，直到但不包括SIG.这些内容以字符串“Tor establess -intro单元格v1”为前缀。

   在接收到ESTABLISH_INTRO单元时，Tor节点首先解码密钥和签名，并检查签名。在这些情况下，节点必须拒绝ESTABLISH_INTRO单元并破坏电路:

        *如果无法识别密钥类型
        *如果密钥格式不正确
        *如签名不正确
        *如果HANDSHAKE_AUTH值不正确

        *如果电路已经是会合电路。
        *如果电路已经是引入电路。[TODO:一些可伸缩性设计失败了。]
        *如果密钥已经被另一个电路使用。

   否则，节点必须将密钥与电路相关联，以便稍后在导入e1单元中使用。

3.1.1.1。拒绝服务国防扩展。(EST_INTRO_DOS_EXT)

   此扩展可用于将DoS参数发送到引入点，以便它将其应用于引入电路。

   属性的N_EXTENSIONS字段中进行编码
   上一节定义的ESTABLISH_INTRO单元格。内容定义如下:

      EXT_FIELD_TYPE:
 [01]——拒绝服务参数。

         如果设置了此标志，引入点应该使用扩展来了解拒绝服务子系统应该使用什么值。

      EXT_FIELD内容格式为:

        N_PARAMS(1个字节)
        N_PARAMS时报》:
           PARAM_TYPE(1个字节)
           PARAM_VALUE(8个字节)

        PARAM_TYPE可能的值是:
 [01]——DOS_INTRODUCE2_RATE_PER_SEC
                 传送到服务的每秒导入单元的速率。
 [02]——DOS_INTRODUCE2_BURST_PER_SEC
                 导入单元的每秒脉冲中继给服务。

        为了容纳64位的值，PARAM_VALUE大小为8个字节。
        它必须匹配以下PARAM_TYPE的指定限制:
 [01]——Min: 0, Max: 2147483647

        值为0表示防御被禁用。如果将每秒的速率设置为0(参数0x01)，则应该忽略突发值。反之亦然，如果突发值是0(参数0x02)，那么速率值应该被忽略。换句话说，将一个参数设置为0将禁用防御。

        脉冲不能小于速率。如果是这样，引入点应该忽略这些参数。

        任何有效值都优先于网络广泛一致的参数。

   使用此扩展可将ESTABLISH_INTRO单元的有效负载扩展19个字节，将其从134个字节扩展到155个字节。

   此扩展只能用于支持协议版本“HSIntro=5”的继电器。

   介绍了tor-0.4.2.1-alpha。

3.1.2。在遗留Tor节点上注册引入点[LEGACY_EST_INTRO]

   Tor节点还应该支持ESTABLISH_INTRO单元的旧版本，它首先在rend-spec.txt中被记录。新的隐藏服务主机在旧主机上建立引入点时必须使用这种格式
   不支持[EST_INTRO]中上述格式的Tor节点。

   在这个旧协议中，一个ESTABLISH_INTRO单元包含:

        KEY_LEN(2字节)
        关键             [ KEY_LEN字节)
        HANDSHAKE_AUTH(20个字节)
        SIG[变量，直到中继有效负载结束]

   KEY_LEN变量决定键字段的长度。

   密钥字段是asn1编码的遗留RSA公钥，它也包含在隐藏的服务描述符中。

   HANDSHAKE_AUTH字段包含(KH |“INTRODUCE”)的SHA1摘要。

   SIG字段包含使用PKCS1填充的所有早期字段的RSA签名。

   旧版本的Tor总是使用1024位的RSA密钥来作为这些介绍身份验证密钥。

3.1.3。确认设立介绍点[INTRO_ESTABLISHED]

   在设置了引入电路之后，引入点将其状态报告给带有INTRO_ESTABLISHED单元的隐藏服务主机。

   INTRO_ESTABLISHED单元格包含以下内容:

     N_EXTENSIONS(1个字节)
     N_EXTENSIONS时报》:
       EXT_FIELD_TYPE(1个字节)
       EXT_FIELD_LEN(1个字节)
       EXT_FIELD (EXT_FIELD_LEN字节)

   旧版本的Tor会返回一个空的INTRO_ESTABLISHED单元。
   服务必须从遗留中继接受一个空白的INTRO_ESTABLISHED单元。

3.2。发送一个导入e1单元到引入点。(SEND_INTRO1)

   为了参与introduction协议，客户端必须知道以下内容:

     *一个服务的介绍点。
     *该引入点的引入身份验证密钥。
     *该引入点的引入加密密钥。

   客户端向引入点发送一个前言e1单元，其中包含服务的标识符、客户端打算使用的加密密钥的标识符，以及一个要转发到隐藏服务主机的不透明blob。

   作为回应，引入点将一个前言- ack单元发送回客户机，通知它它的请求已经被传递，或者它的请求将不会成功。
 指定tor在接收到畸形单元格时应该做什么。下降吗?
          杀电路?这适用于所有可能的细胞。

3.2.1之上。单元格格式[FMT_INTRO1]

   当客户端连接到引入点时，引入e1单元格应该采用以下形式:

     LEGACY_KEY_ID(20个字节)
     AUTH_KEY_TYPE(1个字节)
     AUTH_KEY_LEN(2字节)
     AUTH_KEY (AUTH_KEY_LEN字节)
     N_EXTENSIONS(1个字节)
     N_EXTENSIONS时报》:
       EXT_FIELD_TYPE(1个字节)
       EXT_FIELD_LEN(1个字节)
       EXT_FIELD (EXT_FIELD_LEN字节)
     加密[中继有效负载结束]

   AUTH_KEY_TYPE的定义在[EST_INTRO]中。目前，唯一的价值
   此单元格的AUTH_KEY_TYPE是Ed25519公钥[02]。

   LEGACY_KEY_ID字段用于区分遗留样式和新样式
   INTRODUCE1细胞。在新的样式介绍e1单元格中，LEGACY_KEY_ID为20零字节。在接收到导入e1单元时，引入点检查
   LEGACY_KEY_ID字段。如果LEGACY_KEY_ID是非零的，那么导入点应该将导入e1单元处理为遗留的导入e1单元。

   在接收到引入e1单元后，引入点检查AUTH_KEY是否与主动引入电路的引入点身份验证密钥匹配。如果是，引入点发送一个
   将具有完全相同内容的e2单元引入到服务，并发送一个
   向客户端引入e_ack响应。

3.2.2。INTRODUCE_ACK单元格格式。(INTRO_ACK)

   一个导入的单元格有以下字段:

     状态(2字节)
     N_EXTENSIONS(1字节)
     N_EXTENSIONS时报》:
       EXT_FIELD_TYPE(1个字节)
       EXT_FIELD_LEN(1个字节)
       EXT_FIELD (EXT_FIELD_LEN字节)

   公认的状态值是:
 [00 00]——成功:单元中继到隐藏服务主机。[00 01]——失败:无法识别服务ID[00 02]——消息格式错误[00 03]——无法将单元格中继到服务

3.3。在隐藏服务处处理导入e2单元。(PROCESS_INTRO2)

   在接收到引入e2单元之后，隐藏服务主机检查AUTH_KEY或LEGACY_KEY_ID字段是否与这个引入电路的键匹配。

   然后，服务主机检查它之前是否收到了包含这些内容的单元，或者约定cookie。如果有，它会无声地将其作为回放。(只要它接受具有相同加密密钥的单元格，它就必须维护重播缓存。注意，下面的加密格式应该是不可延展性的。)

   如果计算单元不是重放，则对加密的字段进行解密，与客户端建立共享密钥，并验证计算单元的全部内容自离开客户端以来未被修改。可能有多种解密加密字段的方法，具体取决于选择的加密密钥类型。介绍握手协议的要求在[介绍握手-请求]中描述。我们在下面的[nt - with - extra data]小节中指定了一个。

   解密的明文必须具有以下形式:

      RENDEZVOUS_COOKIE                           [ 20个字节)
      N_EXTENSIONS                                [ 1字节)
      N_EXTENSIONS时报》:
          EXT_FIELD_TYPE                          [ 1字节)
          EXT_FIELD_LEN                           [ 1字节)
          EXT_FIELD                               [ EXT_FIELD_LEN字节)
      ONION_KEY_TYPE                              [ 1字节)
      ONION_KEY_LEN                               [ 2字节)
      ONION_KEY                                   [ ONION_KEY_LEN字节)
      NSPEC(链接说明符的数量)[1字节]
      NSPEC时报》:
          LSTYPE(链接说明符类型)[1字节]
          LSLEN(链接说明符长度)[1字节]
          LSPEC(链接说明符)[LSLEN字节]
      填充(可选填充)[直到明文结束]

   在处理此明文之后，隐藏服务确保扩展字段中存在任何必需的身份验证，然后使用ONION_KEY将集合电路扩展到LSPEC字段中描述的节点，以完成扩展。正如在[构建块]中提到的，必须提供“tcp上的TLS-over-TCP, IPv4”和“遗留节点标识”说明符。

   在0.4.1.1-alpha中，客户端在导入e1单元中包括IPv4和IPv6链接说明符。所有可用的地址都应该包含在单元中，而不管客户机实际用于扩展到集合点的地址是什么。

   隐藏服务应该像客户端在2.5.2.2节中所做的那样处理无效或未识别的链接说明符。特别是,服务
   可以对链接说明符执行基本的有效性检查，并且不应该拒绝未识别的链接说明符，以避免信息泄漏。

   ONION_KEY_TYPE字段为:
 ONION_KEY是32字节长。

   ONION_KEY字段描述了在扩展到集合点时必须使用的洋葱键。它必须是隐藏服务描述符中列出的受支持的类型。

   在使用遗留引入点时，必须使用加密部分中的PAD字段将引入单元格填充到一定长度。

   在接收到格式良好的导入e2单元后，隐藏服务主机将具有:

     *连接到客户选择的集合点所需的信息。
     *与隐藏服务客户端验证和建立共享密钥的握手的第二部分。
     *用于端到端加密的一组共享密钥。

3.3.1。握手加密要求

   当解码加密信息在一个导入e2单元，一个隐藏的服务主机必须能够:

     *解密包含在导入e2单元中的额外信息，以包括会合令牌和扩展到会合点所需的信息。

     *建立一组共享密钥供客户端使用。

     *确认单元在客户端生成后没有被修改过。

   请注意，以前隐藏服务设计中的旧的tap派生协议实现了前两个需求，但没有实现第三个需求。

3.3.2。加密握手示例:ntor与额外数据[ntor与额外数据]
 (TODO:搬迁)

   这是ntor握手的一个变体(请参阅tor规范)。三,部分
   5.1.4;看到提案216;参见Goldberg、Stebila和
   Ustaoglu)。

   它的行为与ntor握手相同，除了协商前向安全密钥之外，它还提供了一种加密非前向安全数据到服务器(在本例中是到隐藏服务主机)的方法，作为握手的一部分。

   这里的表示法在tor规范的5.1.4节中。txt，它定义了ntor握手。

   这个变种的原型是“tor-hs-ntor-curve25519-sha3-256-1”。
   我们也使用以下的调整值:
 t_hsenc = PROTOID | ":hs_key_extract" t_hsverify = PROTOID | ":hs_verify" t_hsmac = PROTOID | "

   要创建一个引入e1单元，客户端必须知道用于此引入电路上的隐藏服务的公共加密密钥B。客户端生成一个一次性的密钥对:
 x, x =注册机()
 和计算:
 intro_secret_hs_input = EXP(B,x) | AUTH_KEY | x | B | PROTOID info = m_hsexpand | subcredential hs_keys = KDF(intro_secret_hs_input | t_hsenc | info, S_KEY_LEN+MAC_LEN)
             ENC_KEY = hs_keys [0 S_KEY_LEN):
             MAC_KEY = hs_keys [S_KEY_LEN S_KEY_LEN + MAC_KEY_LEN):
 并发送，作为导入e1单元的加密部分:

          CLIENT_PK                 [ PK_PUBKEY_LEN字节)
          ENCRYPTED_DATA[填充成明文长度]
          MAC                       [ MAC_LEN字节)


   我们将这些字段替换为上面[FMT_INTRO1]中描述的前言e1单元格主体格式

            LEGACY_KEY_ID                [ 20个字节)
            AUTH_KEY_TYPE                [ 1字节)
            AUTH_KEY_LEN                 [ 2字节)
            AUTH_KEY                     [ AUTH_KEY_LEN字节)
            N_EXTENSIONS                 [ 1字节)
            N_EXTENSIONS时报》:
               EXT_FIELD_TYPE            [ 1字节)
               EXT_FIELD_LEN             [ 1字节)
               EXT_FIELD                 [ EXT_FIELD_LEN字节)
            加密:
               CLIENT_PK                 [ PK_PUBKEY_LEN字节)
               ENCRYPTED_DATA[填充成明文长度]
               MAC                       [ MAC_LEN字节)

 (这种格式如上面的[FMT_INTRO1]中所述，只是这里描述了如何构建加密部分。)

   在这里，加密密钥在常规ntor握手中扮演B的角色，AUTH_KEY字段扮演节点ID的角色。
   CLIENT_PK字段是公钥x。ENCRYPTED_DATA字段是消息明文，使用对称密钥ENC_KEY加密。的
   MAC字段是从AUTH_KEY到ENCRYPTED_DATA末尾的所有单元格的MAC，使用MAC_KEY值作为其键。

   为了处理这种格式，隐藏服务根据需要检查PK_VALID(CLIENT_PK)，然后像客户端上面做的那样计算ENC_KEY和MAC_KEY，除了在计算intro_secret_hs_input时使用EXP(CLIENT_PK,b)。然后服务主机检查MAC是否正确。如果无效，则删除单元格。否则，它通过解密ENCRYPTED_DATA来计算明文。

   隐藏的服务主机现在完成扩展ntor握手的服务端，正如在tor-spec.txt 5.1.4节中描述的那样，使用上面给出的修改后的PROTOID。显式地，隐藏服务主机生成一个密钥对y, y = KEYGEN()，并使用其引入点加密密钥“b”计算:
 intro_secret_hs_input = EXP(X,b) | AUTH_KEY | X | b | PROTOID info = m_hsexpand | subcredential hs_keys = KDF(intro_secret_hs_input | t_hsenc | info, S_KEY_LEN+MAC_LEN)
      HS_DEC_KEY = hs_keys [0 S_KEY_LEN):
      HS_MAC_KEY = hs_keys [S_KEY_LEN S_KEY_LEN + MAC_KEY_LEN):
 (以上是用来检查MAC，然后解密加密的数据。)
 rend_secret_hs_input = EXP(X,y) | EXP(X,b) | AUTH_KEY | b | X | y | PROTOID
      验证= MAC(rend_secret_hs_input, t_hsenc) auth_input = verify | AUTH_KEY | B | Y | X | PROTOID | "Server"
      AUTH_INPUT_MAC = MAC(auth_input, t_hsmac)
 (以上是用来完成ntor握手的。)

   服务器的握手回复为:

       [PK_PUBKEY_LEN bytes]
       AUTH AUTH_INPUT_MAC [MAC_LEN bytes]

   属性将这些字段发送到在RENDEZVOUS1单元中的客户端
   HANDSHAKE_INFO元素(参见[JOIN_REND])。

   隐藏服务主机现在还知道握手生成的密钥，它将使用这些密钥加密和认证客户机和服务器之间的端到端数据。这些键在tor-spec.txt第5.1.4节中计算。

3.4。在引入阶段进行身份验证。(INTRO-AUTH)

   隐藏服务可能只限制授权用户访问。
   这样做的一种机制是凭据机制，其中只有知道隐藏服务凭据的用户才能进行连接。

3.4.1。Ed25519-based身份验证。

   要使用Ed25519私钥进行身份验证，用户必须在导入e1单元的加密部分中包含一个扩展字段
   EXT_FIELD_TYPE类型的[02]和内容:

        Nonce(16字节)
        Pubkey(32个字节)
        签名(64字节)

   Nonce是一个随机值。Pubkey是将用于身份验证的公钥。[TODO:这应该是公钥的标识符吗?]使用Ed25519的签名为:
 “hidserv-userauth-ed25519”
        现时(同上)
        Pubkey(同上)
        AUTH_KEY(在导入e1单元中)

   隐藏的服务主机通过检查它是否能够识别并接受来自所提供公钥的签名来进行检查。如果是，则检查签名是否正确。如果是，则正确的用户已经过身份验证。

   整个计算单元上的重播阻止足以防止身份验证上的重播。

   用户不应该对多个隐藏服务使用相同的公钥。

4. 对接协议

   在连接到一个隐藏的服务之前，客户端首先建立一个电路到一个任意选择的Tor节点(称为会合点)，并发送一个ESTABLISH_RENDEZVOUS单元。隐藏服务随后连接到同一个节点并发送一个集合单元。一旦这发生，中继将集合单元的内容转发给客户端，并将两个电路连接在一起。

   单洋葱服务试图建立一个非匿名单跳电路，但使用匿名三跳电路，如果:

     * rend点在一个被配置为不能通过直接连接到达的地址上，或者
     *通过单跳电路连接到rend点的最初尝试失败，他们正在重新尝试rend点连接。

4.1。建立一个集合点[EST_REND_POINT]

   客户端向集合点发送一个RELAY_COMMAND_ESTABLISH_RENDEZVOUS单元格，该单元格包含一个20字节的值。

            RENDEZVOUS_COOKIE          [ 20个字节)

   集合点必须忽略任何额外的字节
   ESTABLISH_RENDEZVOUS细胞。(旧版本的Tor则没有。)

   rendezvous cookie是由客户端随机选择的一个20字节的任意值。客户端应该为每次新的连接尝试选择一个新的约会cookie。如果集合cookie已经在现有电路上使用，集合点应该拒绝它并破坏电路。

   在接收到ESTABLISH_RENDEZVOUS单元时，会合点将cookie与它被发送的电路相关联。它用空的RENDEZVOUS_ESTABLISHED单元格响应客户端，以表示成功。在RENDEZVOUS_ESTABLISHED单元中，客户端必须忽略任何额外的字节。

   除了与指定位置隐藏服务会合外，客户端不能将发送单元的电路用于任何目的。

   在尝试连接到隐藏服务之前，客户端应该建立一个集合点。

4.2。连接到会合点

   为了完成一个会合，隐藏服务主机建立一个电路到会合点，并发送一个汇合1单元包含:

       RENDEZVOUS_COOKIE           [ 20个字节)
       HANDSHAKE_INFO              [ 变量;取决于使用的握手类型。
 RENDEZVOUS_COOKIE是客户在介绍期间建议的cookie(见[PROCESS_INTRO2])和HANDSHAKE_INFO是定义在[ntor - with - additional data]。

   如果cookie匹配集合点上任何尚未连接的电路上设置的集合cookie，集合点连接两个电路，并发送一个汇合2单元到包含汇合1单元的HANDSHAKE_INFO字段的客户端。

   在接收RENDEZVOUS2单元，客户端验证HANDSHAKE_INFO正确完成握手。为此，客户端解析SERVER_PK
   HANDSHAKE_INFO，反转section [ntor - with- extra data]的最终操作，如下所示:
 rend_secret_hs_input = EXP(Y,x) | EXP(B,x) | AUTH_KEY | | x | Y | PROTOID
      验证= MAC(ntor_secret_input, t_hsenc) auth_input =验证| AUTH_KEY | B | Y | X | PROTOID | "Server"
      AUTH_INPUT_MAC = MAC(auth_input, t_hsmac)

   最后，客户端验证接收到的HANDSHAKE_INFO的认证字段是否等于计算得到的AUTH_INPUT_MAC。

   现在双方都使用握手输出来派生用于下面章节中指定的电路上的共享密钥:

4.2.1。准备关键的扩张

   隐藏的服务及其客户端需要从
   握手输出的NTOR_KEY_SEED部分。为此，他们使用KDF结构如下:

       K = KDF(NTOR_KEY_SEED | m_hsexpand, HASH_LEN * 2 + S_KEY_LEN * 2)

   K的第一个HASH_LEN字节构成前向摘要Df;下一个HASH_LEN字节形成向后摘要Db;下一个S_KEY_LEN字节来自Kf，最后一个S_KEY_LEN字节来自Kb。K中的多余字节被丢弃。

   随后，会合点通过中继单元，不改变，从两个电路的每一个到另一个。当Alice的OP沿电路发送中继单元时，它用Df进行身份验证，用Kf加密，然后用Alice这边的ORs的所有密钥加密;当
   Alice的OP从电路接收中继单元，用Alice这边电路中ORs的密钥解密，然后用Kb解密，用Db检查完整性。Bob的OP也做同样的事情，只是交换了Kf和Kb。
 [TODO:我们应该加密HANDSHAKE_INFO，就像我们加密了介绍e2内容一样吗?这是不必要的，但可能是明智的。类似地，我们应该使它可扩展。

4.3。使用遗留主机作为集合点

   与此协议的旧版本相比，ESTABLISH_RENDEZVOUS的行为没有改变，只是继电器现在应该在末尾忽略意外的字节。

   旧版本的Tor要求集合单元的有效载荷是精确的
   168个字节长。所有较短的会合点有效载荷都应该用随机字节填充到这个长度，使它们难以与会合点的旧协议区分。

   下一代洋葱服务不应该将大于0.2.9.1的中继用于集合点，因为它们对集合单元执行过于严格的长度检查。因此，建议#264中的“HSRend”协议应该用于为会合点选择中继。

5. 加密客户端和主机之间的数据

   中嵌入的成功完成的握手
   引入/集合单元，给客户端和隐藏服务主机一组共享的密钥Kf, Kb, Df, Db，它们用于发送端到端通信加密和认证，就像常规的那样
   Tor中继加密协议，在其他加密之前使用这些密钥进行加密，在其他解密之前使用这些密钥进行解密。客户端使用Kf加密，使用Kb解密;服务主机则相反。

6. 洋葱地址编码[ONIONADDRESS]

   隐藏服务的洋葱地址包括它的身份公钥，一个版本字段和一个基本校验和。所有这些信息用base32编码，如下所示:
 onion_address = base32(PUBKEY |校验和|版本)+ ".onion"
     校验和= H(”。洋葱校验和" | PUBKEY |版本" [:2]
 地点:
       - PUBKEY是隐藏服务的32字节ed25519主PUBKEY。
       - VERSION是一个一个字节的版本字段(默认值'\x03')
       - - - - - -”。是一个常量字符串
       -校验和在插入到onion_address之前被截断为两个字节

  这里有几个例子地址:
 pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd。洋葱sp3k262uwy4r2k3ycr5awluarykdpag6a7y33jxop4cs2lu5uz5sseqd。洋葱xa4r2iadxm55fbnqgwwi5mymqdcofiu3w6rpbtqn7b2dyn7mgwj64jyd.onion

   有关此编码的更多信息，请参见我们的讨论线程[ONIONADDRESS-REFS]。

7. 开放式问题:

   扩展隐藏服务是困难的。有一些正在进行的讨论，你也许能帮上忙。看到[SCALING-REFS]。

   我们如何改进[SHAREDRANDOM]中提出的HSDir不可预测性设计?请参阅[SHAREDRANDOM-REFS]进行讨论。

   隐藏的服务地址如何在保持其自我认证和去中心化特性的同时变得令人难忘?一些建议见[HUMANE-HSADDRESSES-REFS];还有更多的可能性。

   隐藏服务非常慢。既因为冗长的设置过程，也因为最后的电路有6个跳。我们如何使隐藏服务协议更快?参见[PERFORMANCE-REFS]获得一些建议。

引用:
 (KEYBLIND-REFS): https://trac.torproject.org/projects/tor/ticket/8106 https://lists.torproject.org/pipermail/tor-dev/2012-September/004026.html
 (KEYBLIND-PROOF): https://lists.torproject.org/pipermail/tor-dev/2013-December/005943.html
 (SHAREDRANDOM-REFS): https://gitweb.torproject.org/torspec.git/tree/proposals/250-commit-reveal-consensus.txt https://trac.torproject.org/projects/tor/ticket/8244
 (SCALING-REFS): https://lists.torproject.org/pipermail/tor-dev/2013-October/005556.html
 [HUMANE-HSADDRESSES-REFS]: https://gitweb.torproject.org/torspec.git/blob/HEAD /建议/想法/ xxx-onion-nyms.txt http://archives.seul.org/or/dev/Dec-2011/msg00034.html
 :《提高Tor电路建立和隐藏服务的效率和简便性》，作者:Overlier, L.， and
        p . Syverson
 [待办事项:这里需要更多!我们有吗?():
 为Tor隐藏服务的拖网:检测，测量，
        《去匿名化》，作者亚历克斯·比尤科夫，伊万·普斯托加洛夫，
        Ralf-Philipp Weinmann
 “定位隐藏服务器”LasseØverlier和保罗
        Syverson
 [ED25519-REFS]:“高速高安全签名”，作者Daniel
        J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe和
        Bo-Yin杨。http://cr.yp.to/papers.html#ed25519
 [ED25519-B-REF]: https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03第5节:
 (PRNG-REFS): http://projectbullrun.org/dual-ec/ext-rand.html https://lists.torproject.org/pipermail/tor-dev/2015-November/009954.html
 (SRV-TP-REFS): https://lists.torproject.org/pipermail/tor-dev/2016-April/010759.html
 (VANITY-REFS): https://github.com/Yawning/horse25519
 (ONIONADDRESS-REFS): https://lists.torproject.org/pipermail/tor-dev/2017-January/011816.html
 (TORSION-REFS): https://lists.torproject.org/pipermail/tor-dev/2017-April/012164.html https://getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html

附录A.密钥盲签名方案[KEYBLIND]

. 1。关键的推导过程概述

  如上面[IMD:DIST]和[SUBCRED]中所述，我们需要一个“按键盲”系统，其工作原理(大致)如下:

        有一个主密钥对(sk, pk)。

        给定密钥对和nonce n，就有一个派生函数给出一个新的盲密钥对(sk_n, pk_n)。此密钥对可用于签名。

        只要给定公钥和现时值，就有一个函数提供pk_n。

        不知道pk，就不可能推导出pk_n;不知道sk，就不可能推导出sk_n。

        可以在只知道pk_n的情况下检查使用sk_n创建的签名。

        看到大量盲公钥和使用这些公钥生成的签名的人无法分辨哪些签名和哪些盲密钥来自同一主密钥对。

        你不能伪造签名。
 [待办事项:插入更严格的定义和更好的引用。]

由信用证。Tor的关键推导方案

  我们提出了以下基于Ed25519的密钥盲方案。
 (这是一个ECC组，记住标量乘法是活板门函数，它是由迭代点加法定义的。请参阅Ed25519论文[参考Ed25519 - refs]获得相当清晰的记录。)

  设B为[ed25519 -B- ref]第5节中所示的ed25519基点:

      B = (15112221349535400772501151409588531511454012693041857206046113283949847762202,
           46316835694926478169428394003475163141307993866256225615783033603165251855960)

  假设B的质阶为l，所以lB=0。让主密钥对写成(a, a)，其中a是私钥，a是公钥(a =aB)。

  为了推导一个现时N和一个可选秘密s的密钥，像这样计算盲因子:
 h = h (BLIND_STRING | A | s | B | N)
           BLIND_STRING = "派生临时签名密钥"
           N = "key-blind"
           B = "(1511[…2202年,4631年[…]5960)”
 然后根据ed25519规范夹住盲因子“h”:
 h [0] & = 248;h [31] & = 63;h [31] | = 64;
 并进行如下关键推导:
 时间段私钥:
 a' = h a mod l
           RH' = SHA-512(RH_BLIND_STRING | RH)[:32]
           RH_BLIND_STRING = "派生临时签名键哈希输入"
 期间的公钥:

           A' = h A = (ha)B

  生成一个M的签名:给定一个确定性随机看r(见EdDSA论文)，取r =rB, S=r+哈希(r, a '，M)ah mod l，发送签名(r,S)和公钥a '。

  签名验证:检查SB = R+哈希(R,A'，M)A'。
 (如签署有效，
       某人= (r +散列(r, A, M)啊)B = rB +(散列(r,“米啊)B = r +散列(r, M))

  这可以归结为具有密钥对(a'， a')的常规Ed25519。

  请参阅[KEYBLIND-REFS]以获得关于该方案和可能的替代方案的广泛讨论。另外，请参阅[KEYBLIND-PROOF]来获得该方案的安全性证明。

附录b选择节点[PICKNODES]

  选择介绍点
  挑选会合点
  建设路径
  重用电路
 (待办事项:这需要一个书面记录)

附录C.寻找虚荣的建议洋葱[虚荣]

  编者注:作者认为，强行使用密钥空间是愚蠢的，当使用base-32编码时，可以拼出你网站的名称。我也觉得有点危险。如果你训练你的用户连接
 llamanymityx4fi3l6x2gyzmtmgxjyqyorj9qsb5r543izcwymle.onion

  我担心你会让别人更容易骗到你
 llamanymityb4sqi0ta0tsw6uovyhwlezkcrmczeuzdvfauuemle.onion

  然而，人们可能会尝试这样做，所以这里有一个不错的算法可以使用。

  搜索具有某些条件X的公钥:

        生成一个随机(sk,pk)对。

        而pk不满足X:

            把数字8加到sk上
            把点8*B加到pk中

        返回sk, pk。

  我们加上8和8乘以B，而不是1和B，所以sk总是有效的
  Curve25519私钥，最低3位等于0。

  该算法是安全的[来源:djb，个人通信][TODO:
  确保我理解正确!只要只使用最后的(sk,pk)对，并且丢弃之前的所有值。

  为了并行化该算法，首先为每个独立线程生成一个独立的(sk,pk)对，然后让每个搜索独立进行。

  请参阅[虚荣心参考]以获得这个虚荣心.onion搜索方案的参考实现。

附录D.本文档中保留的数值
 [TODO:收集上面提到的所有命令和值的列表]

附录E.预留号码

  我们为Ed25519证书保留这些证书类型值:
 [08]短期描述符签名密钥，用盲公钥签名。[09]介绍点身份验证密钥，对描述符签名密钥进行交叉验证。(第2.5节)[0B] ed25519密钥来自curve25519介绍点加密密钥，交叉验证描述符签名密钥。(2.5节)

      注意:忽略了值“0A”，因为它是为提议228中的交叉认证ntor身份键预留的。

附录F.隐藏服务目录格式[HIDSERVDIR-FORMAT]

  这个附录部分指定了HiddenServiceDir目录的内容:

  ——“主机名 "                                       [ 文件)

   这个文件包含洋葱服务的洋葱地址。

  ——“private_key_ed25519 "                            [ 文件)

   这个文件包含洋葱服务的私有主密钥ed25519。(TODO:离线键)

  - - - - - -”。/ authorized_clients /"                  [ 目录”。/ authorized_clients /爱丽丝。身份验证 "        [ 文件”。/ authorized_clients /鲍勃。身份验证 "          [ 文件”。/ authorized_clients查理。身份验证”(文件)

   如果启用了客户端授权，此目录必须包含一个"。每个授权客户的认证文件。每个这样的文件都包含各自客户端的公钥。文件由客户端传输到服务操作员。

   有关客户端文件的详细信息和格式，请参阅[client - aum - mgmt]一节。
 (注:客户端授权在0.3.5.1-alpha实现。)

附录G.管理授权客户数据[client - auth - mgmt]

  隐藏服务和客户端可以使用torrc或控制端口配置其授权客户端数据。本节介绍一种配置客户端授权的建议方案。有关相关隐藏服务文件的更多信息，请参见附录[HIDSERVDIR-FORMAT]。
 (注:客户端授权在0.3.5.1-alpha实现。)

  G.1。使用torrc配置客户端授权

  G.1.1。隐藏服务端配置

     希望启用客户机授权的隐藏服务需要用“”填充其HiddenServiceDir目录的“authorized_clients/”目录。授权客户的文件。

     当Tor启动一个配置好的洋葱服务时，Tor检查其<HiddenServiceDir>/authorized_clients/目录中的"。如果找到了任何可识别和解析的文件，那么该服务的客户端授权将被激活。

  G.1.2。服务端记账

     这部分包含了更多关于onion服务应该如何跟踪他们的客户的细节。身份验证”文件。

     对于“描述符”身份验证类型，为。auth”文件必须包含该客户端的x25519公钥。以下是建议的文件格式:
 < auth-type >: <键式>:< base32-encoded-public-key >

     下面是一个例子:
 描述符:x25519: OM7TGIVRYMY6PFX6GAC6ATRTA5U6WW6U7A4ZNHQDI6OVL52XVV2Q

     Tor应该忽略它不能识别的行。
     Tor应该忽略不使用"的文件。身份验证”后缀。

  G.1.3。客户端配置

     想要为onion services注册客户端授权数据的客户端需要在他们的torrc中添加下面的行来指示所托管的目录”。auth_private"文件包含洋葱服务的客户端凭据:

         ClientOnionAuthDir < DIR >

     <DIR>包含一个后缀为"的文件。“auth_private”用于客户机授权的每个洋葱服务。Tor应该扫描该目录以查找"。来查找哪个洋葱服务需要这个客户机的客户端授权。

     对于“描述符”auth-type，为“。auth_private"文件包含私有的x25519密钥:
 < onion-address >:描述符:x25519: < base32-encoded-privkey >

     用于客户端授权的密钥对是由第三方工具创建的，需要以带外的安全方式将公钥传输给服务操作符。第三方工具应该在私钥文件中添加适当的头，以确保用户不会意外地泄露他们的私钥。

  G.2。使用控制端口配置客户端授权

  G.2.1。服务端

     隐藏服务还可以使用控制端口配置授权客户端。其思想是，隐藏的服务操作人员可以使用控制器实用程序来管理他们的访问控制，而不是使用文件系统来注册客户端密钥。

     具体来说，我们需要一个新的控制端口命令ADD_ONION_CLIENT_AUTH，它能够注册x25519/ed25519与特定授权客户端绑定的公钥。[XXX计算控制端口命令格式]

     使用客户端验证控制端口接口的隐藏服务需要执行自己的密钥管理。

  G.2.2。客户端

     还应该有一个控制端口接口供客户端注册隐藏服务的授权数据而不必使用torrc。它应该允许生成客户端授权私钥，也允许导入由隐藏服务提供的客户端授权数据

     这样，当用户试图访问一个被客户授权保护的隐藏服务时，Tor浏览器可以显示“生成客户授权密钥”和“导入客户授权密钥”对话框。

     具体来说，我们需要两个新的控制端口命令:
                   IMPORT_ONION_CLIENT_AUTH_DATA
                   GENERATE_ONION_CLIENT_AUTH_DATA，分别导入和生成客户端授权数据。
 这里的密钥管理是如何工作的?当人们同时使用控制端口接口和文件系统接口时会发生什么?

附录F.管理修订计数器的两种方法。

  实现可以以任何他们喜欢的方式生成修订计数器，只要它们在每个盲公钥的生命周期中单调地增加。但是为了避免指纹识别，实现者应该选择一种其他Tor实现也使用的策略。这里我们描述了两种策略，并另外列出了实现者不应该使用的一些策略。

  F.1。Increment-on-generation

    这是最简单的策略，也是Tor在至少0.3.4.0-alpha版本中使用的策略。

    每当使用一个新的盲密钥时，服务记录它与该密钥一起使用的最高修订计数器。在生成描述符时，服务使用比它已经使用过的任何数字都要大的最小非负数。

    换句话说，这个系统下的修订计数器重新启动，每个盲键为0、1、2、3，等等。

  F.2。加密周期

    当多个服务实例需要协调它们的修订计数器，而没有实际的协调机制时，我们推荐使用此方案。

    设T为自描述符生效以来所经过的秒数，再加上1。(T必须至少为1)实现可以使用与此描述符对应的共享随机协议运行开始时间以来的秒数。

    让我们成为所有服务提供者共享的秘密。例如，它可以是与当前盲密钥对应的私有签名密钥。

    设K为AES-256密钥，生成为
        K = H(“rev-counter-generation”| S)

    在计数器模式下使用K和AES (IV=0)生成一个T流
    * 2字节。将这些字节看作由16位小端字组成的序列。把这些单词。

    让这些词的总和成为修订计数器。


    Cryptowiki将这个方案大致归功于G. Bebek:

         g . Bebek。反篡改数据库研究:推理控制技术。技术报告eecs433最终报告，案例
         西储大学，2002年11月。

    虽然我们认为它适合在这个应用程序中使用，但它并不是一个完美的保持顺序的加密算法(而且所有保持顺序的加密都有缺点)。在用它做其他任何事情之前请三思。
 这个方案可以很容易地优化缓存加密
    X*1, X*2, X*3，等等。

    有关缓慢的参考实现，请参见
    Tor源存储库。现在，在Nick的“ope_hax”分支中看到相同的文件——它还没有合并。

    此方案目前还没有在Tor中实现。

  f.x一些需要避免的修正策略

    虽然听起来很诱人,实现不应该使用当前时间或当前时间期限内直接作为修订计数器——这样做泄漏他们的当前时间,可用于洋葱服务与其他服务在同一主机上运行。

    类似地，实现不应该让修订计数器在不重置它的情况下永远增加——这样做会在盲公钥的更改之间链接服务。
