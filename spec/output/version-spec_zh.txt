

                        TOR版本号是如何工作的

1. 老方法

 在0.1.0之前，版本的格式是:

     MAJOR.MINOR.MICRO(状态(PATCHLEVEL)) ? (cvs) ?
 当MAJOR、MINOR、MICRO和PATCHLEVEL是数字时，状态是“pre”(对于一个alpha版本)、“rc”(对于一个候选版本)或者“.”(对于一个版本)。作为特例，“a.b.c”相当于“a.b.c.0”。我们按顺序比较元素(major、minor、micro、status、patchlevel、cvs)，并将“cvs”放在非cvs之前。

 我们在开始每个开发分支时都要记住一个最终版本:比如“0.0.8”。我们的第一个预发布版本是“0.0.8pre1”，后面跟着(例如)“0.0.8pre2-cvs”、“0.0.8pre2”、“0.0.8pre3-cvs”、“0.0.8rc1”、“0.0.8rc2-cvs”,“0.0.8rc2”。最后,我们会发布
 0.0.8。稳定的CVS分支的版本将被命名为“0.0.8.1- CVS”，而任何最终的bug修复版本将被命名为“0.0.8.1”。

2. 的新方法

 从0.1.0.1-rc开始，版本的格式如下:

    MAJOR.MINOR.MICRO(。PATCHLEVEL] [-STATUS_TAG] [(EXTRA_INFO)] *

 括号中的内容是可选的。与前面一样，主、副、微和补丁级别都是数字，缺失的数字等于0。
 所有的版本都应该通过这四个数字来区分。

 STATUS_TAG是纯粹的信息，让你知道我们认为这个版本有多稳定:“alpha”非常不稳定;“rc”是一个发行候选版本;没有标签意味着我们有一个最终版本。如果标签以“-cvs”或“-dev”结尾，那么您看到的是一个给定发行版之后的开发快照。如果我们*确实*遇到了仅在状态标签上不同的两个版本，我们就在词汇上对它们进行比较。STATUS_TAG不能包含空格。

 EXTRA_INFO也是纯粹的信息，通常包含关于提交这个版本的SCM的信息。它被圆括号包围，不能包含空格。与STATUS_TAG不同，它不会影响版本比较的方式。EXTRA_INFO可能出现任何次数。工具通常不应该解析EXTRA_INFO条目。

 现在，我们用(比如说)0.1.1.1-alpha开始每个开发分支。补丁级别会随着状态标签的变化而不断增加，例如:0.1.1.2-alpha, 0.1.1.3-alpha, 0.1.1.4-rc, 0.1.1.5-rc。
 最终，我们发布了0.1.1.6。下一个补丁版本是0.1.1.7。

 在这两个版本之间，CVS的版本使用-cvs标记:after
 0.1.1.1-alpha是0.1.1.1-alpha-cvs，以此类推。但从
 在0.1.2.1-alpha-dev中，我们切换到SVN并开始使用“-dev”后缀而不是“-cvs”后缀。

3.版本状态。

  有时，我们需要根据推荐版本列表来确定Tor版本是否已经过时、处于实验阶段，或者两者都不是。其逻辑如下:

   *如果一个版本出现在推荐列表中，则为“推荐”。

   *如果一个版本比所有推荐的版本都要新，那么这个版本就是“实验版”或“新版”。

   *如果一个版本比每个推荐版本都要早，那么这个版本就是“obsolete”或“old”的。

   *版本号的前三个组成部分(主、次、微)是它的“发布系列”。如果一个版本具有具有相同发布系列的其他推荐版本，并且该版本比所有推荐版本都要新，但又不是所有推荐版本都要新，那么该版本就是“新系列”。

   *最后，如果以上条件均不满足，则“不推荐”该版本。
