

                    Tor对接规范

0. 概述和预赛

      “必须”、“不得”、“必须”、“应当”、“应当”等关键词
      本文档中的“不”、“应该”、“不应该”、“推荐”、“可能”和“可选”将按照中描述的方式解释
      RFC 2119。

   阅读https://svn.torproject.org/svn/projects/design-paper/tor-design.html#sec:在阅读本规范之前会合。这样做会更有意义。

   集合点为洋葱路由网络提供位置隐藏服务(服务器匿名)。与会合点,
   Bob可以通过onion路由网络提供一个TCP服务(比如一个web服务器)，而不需要显示该服务的IP。

   Bob通过匿名发布他的服务的公钥以及作为“介绍”的洋葱路由器列表来实现这一点
   他的发球得分。他为这些介绍点创建前向电路，并告诉他们他的服务。为了连接到鲍勃，爱丽丝首先建立了一个电路或作为她的“会合点”。然后，她连接到鲍勃选择的一个介绍点，并要求它告诉他她的约会地点
   点(RP)。如果鲍勃选择回答，他就给她建立一个电路
   然后告诉它把他和Alice连接起来。RP将它们的电路连接在一起，并开始传送细胞。Alice的'BEGIN'单元格直接由Bob的OP接收，OP向实现Bob的服务的本地服务器传递数据，并从中传递数据。

   下面我们将描述此服务的网络级规范，以及使此过程对Alice透明的接口(只要她使用OP)。

0.1。符号、约定和先决条件

   在下面的规范中，我们使用与“tor-spec.txt”中相同的符号和术语。这里指定的服务还需要存在在该文件中指定的洋葱路由网络。

        H(x)是x的SHA1摘要。
        PKSign(SK,x)是带有SK的x的pkcs .1填充RSA签名。
        PKEncrypt(SK,x)是一种pkcs .1填充RSA的x加SK加密。
        公钥都是RSA，用ASN.1编码。
        所有整数都以网络(big-endian)顺序存储。
        除非另有说明，否则所有对称加密都在计数器模式下使用AES。

   在所有讨论中，“Alice”指的是连接到位置隐藏服务的用户，“Bob”指的是运行位置隐藏服务的用户。

   OP是一个“洋葱代理”或Tor客户端(定义在其他地方)。

   OR是(定义在其他地方)“洋葱路由器”或Tor服务器。

   “介绍点”是选择Tor服务器作为Bob的中期“会面地点”。“会合点”是Alice选择的Tor服务器，作为她和Bob之间的短期通信中继。所有Tor服务器都可能充当引入点和集合点。

0.2。协议概述

   1. Bob的OP:“提供IP:Port作为公钥名:Port”。[配置](我们没有指定此步骤;的实现者
      鲍勃的相机会)。

   2. Bob的OP生成一个长期密钥对。

   3.Bob的OP->引入点通过Tor:[引入设置]“这个公钥(当前)关联到我。”

   4. Bob的OP->目录服务通过Tor发布Bob的服务描述符[广告]“在引入点A、B或c满足公钥X”(签署)

   5. 在带外，Alice接收到一个z.onion:端口地址。
      她打开一个到OP的SOCKS连接，并请求z.onion:端口。

   6. Alice的OP通过Tor检索Bob的描述符。(描述符查找。)

   7. Alice的OP选择一个会合点，打开一条线路到那个会合点，并建立一个会合线路。(会合的设置。)

   8. 爱丽丝通过Tor连接到引入点，并告诉它她的集合点。(加密给Bob)[简介1]

   9. 引入点沿着引入电路通过Tor将这些信息传递给Bob的OP。[介绍2]

  10. Bob的OP决定是否连接到Alice，如果连接到Alice的RP，则通过Tor创建一个电路。建立一个共享电路。[会合1]

  11. 集合点将Bob的确认转发给Alice的操作。

  12. Alice的OP将开始单元发送给Bob的OP。[连接]

0.3。常量和新的单元格类型

  传递细胞类型

      32 - RELAY_COMMAND_ESTABLISH_INTRO
      33 - RELAY_COMMAND_ESTABLISH_RENDEZVOUS
      34 - RELAY_COMMAND_INTRODUCE1
      35——RELAY_COMMAND_INTRODUCE2
      36——RELAY_COMMAND_RENDEZVOUS1
      37 - RELAY_COMMAND_RENDEZVOUS2
      38——RELAY_COMMAND_INTRO_ESTABLISHED
      39 - RELAY_COMMAND_RENDEZVOUS_ESTABLISHED
      40——RELAY_COMMAND_INTRODUCE_ACK

0.4。版本概述

   隐藏服务协议中有几个部分随着时间而变化，每个部分都有自己的版本号，而其他部分保持不变。下面列出的可能版本化的协议部分应该有助于减少一些混乱:

   -隐藏服务描述符:基于二进制的v0长期以来都是默认的，提案114已经添加了基于ascii的v2。v0描述符格式在0.2.2.1-alpha中已被弃用。见1.3。

   -隐藏服务描述符传播机制:目前与隐藏服务描述符版本相关——v0发布到原来的hs目录权限，而v2发布到带有“HSDir”标志的继电器的旋转子集;见1.4和1.6。

   -如何生成一个引入单元的引入协议:v0指定了一个集合点的昵称，并假定中继会知道它，而v2现在指定了IP地址，端口和洋葱密钥，所以中继不需要已经识别它。见1.8。

1. 该协议

1.1。Bob配置他的本地操作。

   我们没有为OP配置文件指定格式。然而,
   OPs应该允许Bob为每个OP提供多个已发布的服务，并且必须允许Bob为每个服务指定一个或多个虚拟端口。Bob提供了从每个虚拟端口到本地IP:端口对的映射。

1.2。鲍勃的发言确立了他的介绍要点。

   OP第一次提供公开的服务时，它生成一个公共/私有密钥对(本地存储)。

   OP选择少量的Tor服务器作为引入点。
   OP为每个引入点建立一个新的引入电路。这些电路只能用于隐蔽服务介绍。为了建立介绍，Bob发送a
   RELAY_COMMAND_ESTABLISH_INTRO细胞,包含:

        KL密钥长度[2八进制]
        PK Bob的公钥或服务密钥[KL octets]
        会话信息的HS散列[20个八位元]
        以上信息签名[变量]

   KL是PK的长度，八进制。

   为了防止重播攻击，HS字段中包含一个基于Bob的OP与引入点共享的秘密KH的SHA-1哈希，具体如下:

       HS = H(KH | "介绍")

   那就是:

       HS = H(KH | [49 4E 54 52 4F 44 55 43 45])
 (KH，在tor规范中指定。txt是H(g^xy | [00])

   在接收到这样的单元时，OR首先检查签名是否与所包含的公钥一致。如果是，它检查HS是否正确给定Bob的OP和OR之间的共享状态。如果任一检查失败，OP将丢弃单元格;否则，它将电路与Bob的公钥相关联，并将当前与PK相关联的任何其他电路解离
   RELAY_COMMAND_INTRO_ESTABLISHED单元格，有效负载为空。

   Bob的OP使用Bob的公钥或RELAY_COMMAND_ESTABLISH_INTRO单元中新生成的、一次性使用的服务密钥，具体取决于配置的隐藏服务描述符版本。公共密钥用于v0描述符，即用于v2描述符的服务密钥。在后一种情况下，所有引入点的服务密钥与其他引入点信息一起包含在v2隐藏服务描述符中。
   原因是引入点不需要也不应该知道它为哪个隐藏服务工作，从而防止它跟踪隐藏服务的活动。如果将隐藏服务配置为同时发布v0和v2描述符，则会建立两组单独的引入点。

1.3。Bob的OP生成服务描述符。

   对于0.2.2.1-alpha之前的版本，Bob的OP定期生成并发布类型为“V0”的描述符。

   “V0”描述符包含:

         KL密钥长度[2八进制]
         PK Bob的公钥[KL octets]
         一个时间戳[4个八进制]
         引入点NI数[2八进制]
         Ipt一个以null结尾的ORs列表[变量]
         以上字段的SIG签名[变量]

   TS是自1970年1月1日以来所经过的秒数。

   Ipt的成员可以是(a)昵称，或者(b)身份密钥摘要，用十六进制编码，并以“$”作为前缀。客户端必须接受这两种表单。服务必须只生成第二种形式。
   一旦0.0.9。x是过时的，我们可以放弃第一种形式。
 鲍勃宣传0个介绍点没问题。如果他之前宣传过一些介绍要点，现在却没有的话，他可能会想这么做。rd)

   从0.2.0.10-alpha开始，Bob的OP编码“V2”描述符(或者代替)“半”的描述符。“V2”描述符的格式如下:
 “会合-服务描述符”SP描述符-id NL
 [在开始时，恰好只有一次][没有额外参数]

       指示描述符的开头。“descriptor-id”是一个定期变化的标识符，160位，格式为32 base32字符，由隐藏服务及其客户端计算。通过执行以下操作计算“description -id”:
 descriptor-id =
             H(永久id | H(时间段|描述符-cookie |副本))
 “permanent-id”是隐藏服务的永久标识符，由80位组成。可以通过计算公共隐藏服务密钥的哈希值并在前80位后截断来计算:
 上海市户籍= H(公钥)[10]

       注意:如果Bob的OP启用了“隐身”授权(参见2.2节)，那么它使用客户端密钥来替代公共隐藏服务密钥。
 “H(时间段|描述符-cookie |副本)”是id部分(可能是秘密的)，必须验证隐藏服务是此描述符的真正发起者，因此也包含在描述符中。描述符ID只能由隐藏服务及其客户端创建，但是下面的“签名”只能由服务创建。
 “时间周期”作为时间和“永久id”的函数周期性地变化。“时间段”的当前值可通过以下公式计算:
 time-period =(当前时间+永久id-字节* 86400 / 256)/ 86400
 “当前时间”包含当前系统时间(以秒为单位)
       1970-01-01 00:00，例如1188241957。“永久id-字节”是永久标识符(按网络顺序排列)的第一个(无符号的)字节，例如143。添加“permanent-id-byte”和的乘积
       86400(每天的秒数)除以256，可以防止“时间周期”在一天的同一时间改变所有描述符。整个操作的结果是一个(网络顺序的)32位整数。
       13753或0x000035B9与上面给出的示例值。
 “descriptor-cookie”是一个可选的128位的秘密密码，在隐藏的服务提供商及其客户端之间共享。如果省略了description -cookie，哈希函数的输入将缩短128位。(没有额外的参数)
 “replica”表示副本的数量。服务发布具有不同描述符id的多个描述符，以便将它们分布到环上的不同位置。
 “版本”SP版本号NL
 [正好一次][没有额外参数]

       此描述符格式的版本号。版本号是正整数。
 “永久密钥”NL: PEM格式的公钥
 [正好一次][没有额外参数]

       隐藏服务的公钥，用于验证“描述符id”和“签名”。
 “秘密部分”SP秘密部分NL
 [正好一次][没有额外参数]

       上面解释的下列操作的结果，格式化为
       32 base32识字课。使用这个秘密id部分，每个人都可以验证签名的描述符属于“description -id”。
 secret-id-part = H(时间段|描述符-cookie |副本)
 “出版时间”SP YYYY-MM-DD HH:MM:SS NL
 (完全一次)

       创建此描述符时的时间戳。应该四舍五入到最接近的时间。
 “协议版本”SP版本字符串NL
 [正好一次][没有额外参数]

       供引入单元使用的认可和允许版本号列表，以逗号分隔;这些版本在章节中有描述
       1.8所示。版本号是正整数。
 “introduction-points”问加密字符串
 [最多一次][无额外参数]

       介绍要点的列表。如果使用可选的“descripter -cookie”，则在CTR模式下使用AES对该列表进行加密，其初始化向量为128位，并将“descripter -cookie”作为长度为128位的密钥写入加密字符串的开头。

       包含引入点数据(加密或未加密)的字符串用base64编码，并使用“——开始消息——”和“——结束消息——”包围。

       最多可获得10个入门点，每项包含以下资料:
 “导入点”SP标识符NL
 [在开始时，恰好只有一次][没有额外参数]

           这个引入点的标识符:这个引入点的标识键的base32编码散列。
 “ip地址”SP ip4 NL
 [正好一次][没有额外参数]

           此介绍点的IP地址。
 “洋葱端口”SP端口NL
 [正好一次][没有额外参数]

           引入点侦听传入洋葱请求的TCP端口。
 一种PEM格式的公钥
 [正好一次][没有额外参数]

           可用于将消息加密到此引入点的公钥。
 “service-key”NL: PEM格式的公钥
 [正好一次][没有额外参数]

           可用于将消息加密到隐藏服务的公钥。
 “介绍认证”auth-type auth-data NL
 (任意数量)

           特定于导入点的身份验证数据可用于执行客户端身份验证。此数据依赖于所选的引入点，而不是上面的“服务身份验证”。auth-data的格式(base64编码或PEM格式)取决于auth类型。有关认证机制的详细信息，请参阅本文档的第2节。
 (这结束了描述符加密部分中的字段。)
 鲍勃宣传0个介绍点没问题。如果他之前宣传过一些介绍要点，现在却没有的话，他可能会想这么做。rd)
 “签名”问签名字符串
 [在结束，恰好一次][没有额外参数]

       使用隐藏服务的私钥对上述所有字段进行签名，包括'"signature" NL'。

1.3.1。其他我们不使用的描述符格式。

   在0.2.2.0-alpha-dev中取消了对V0描述符格式的支持:

         KL密钥长度[2八进制]
         PK Bob的公钥[KL octets]
         一个时间戳[4个八进制]
         引入点NI数[2八进制]
         Ipt一个以null结尾的ORs列表[变量]
         以上字段的SIG签名[变量]

   KL是PK的长度，八进制。
   TS是自1970年1月1日以来所经过的秒数。

   Ipt的成员可以是(a)昵称，或者(b)身份密钥摘要，用十六进制编码，并以“$”作为前缀。

   V1描述符格式被理解和接受
   从0.1.1.5-alpha-cvs到0.2.0.6-alpha-dev，但是没有函数生成，因此被删除:

         V格式字节:设置为255[1八位元组]
         V版本字节:设置为1[1八位元组]
         KL密钥长度[2八进制]
         PK Bob的公钥[KL octets]
         一个时间戳[4个八进制]
         原始协议版本:位掩码[2个八进制]
         引入点NI数[2八进制]
         对于每个介绍点:(如在介绍e2单元中)
             IP引入点地址[4个八进制]
             端口引入点或端口[2八字节]
             ID引入点标识ID [20 octets]
             洋葱键的KLEN长度[2八进制]
             洋葱键[KLEN octets]
         以上字段的SIG签名[变量]

   一个假设的“V1”描述符，它从未被使用过，但可能由于历史原因而有用，它包含:

         V格式字节:设置为255[1八位元组]
         V版本字节:设置为1[1八位元组]
         KL密钥长度[2八进制]
         PK Bob的公钥[KL octets]
         一个时间戳[4个八进制]
         原型交会协议版本:位掩码[2个八位元]
         接受的认证机制的NA数[1个八隅体]
         对于每个认证机制:
             支持的auth类型[2个八进制]
             认证数据的AUTHL长度[1八字节]
             AUTHD Auth数据[变量]
         引入点NI数[2八进制]
         对于每个介绍点:(如在介绍e2单元中)
             指定一个地址类型(通常是4个)[1个八位元]
             ADDR引入点的IP地址[4或16八进制]
             端口引入点或端口[2八字节]
             支持的auth类型[2个八进制]
             认证数据的AUTHL长度[1八字节]
             AUTHD Auth数据[变量]
             ID引入点标识ID [20 octets]
             洋葱键的KLEN长度[2八进制]
             洋葱键[KLEN octets]
         以上字段的SIG签名[变量]

   AUTHT指定隐藏服务或引入点需要哪种身份验证/授权机制。AUTHD是可以与认证方法关联的任意数据。
   目前只支持AUTHT的[00 00]，AUTHL为0。
   有关认证机制的详细信息，请参阅本文档的第2节。

1.4。Bob的OP宣传他的服务描述符。

   Bob的OP将他的服务描述符广告给一组固定的v0隐藏服务目录服务器和/或所有v2隐藏服务目录的一个不断变化的子集。

   对于0.2.2.1-alpha之前的版本，Bob的OP通过Tor打开一个流，指向每个v0目录服务器的目录端口。(他可能会为此重复使用旧电路。)通过这个流，Bob的OP向一个相对于目录服务器根的URL“/tor/rendezvous/publish”发出HTTP“POST”请求，该请求的主体包含Bob的服务描述符。

   在接收到描述符后，目录服务器检查签名，如果签名与所包含的公钥不匹配，则丢弃描述符。接下来，目录服务器检查时间戳。如果时间戳在过去超过24小时，或者在未来超过1小时，或者目录服务器已经有一个具有相同公钥的较新的描述符，服务器将丢弃该描述符。否则，服务器将丢弃具有相同公钥和版本格式的所有旧描述符，并将新的描述符与公钥关联。
   目录服务器记住这个描述符的时间戳之后至少24小时。至少每18个小时，Bob的OP上传一个新的描述符。

   如果Bob的OP被配置为发布v2描述符，那么它将发布所有v2隐藏服务目录的一个不断变化的子集，而不是权威目录服务器。因此，Bob的OP通过
   Tor到每个负责隐藏的服务目录。(他可能会为此重复使用旧电路。)通过这个流，Bob的OP向一个相对于隐藏服务目录根的URL“/tor/rendezvous2/publish”发出HTTP 'POST'请求，其中包含Bob的服务描述符作为其主体。
 为HS dir岗位重用旧电路是非常糟糕的。我们真的这么做吗?(RR)

   在任何时候，都有6个隐藏的服务目录负责保存一个描述符的副本;它们由2组3个具有连续洋葱id的隐藏服务目录组成。Bob的OP通过过滤从目录权威接收到的共识状态文档来了解隐藏服务目录的完整列表。如果一个隐藏的服务目录具有HSDir标志，并且它的标识摘要是循环列表中在描述符ID后面的HSDir中继的前三个标识摘要之一，那么该服务目录被认为负责描述符ID。根据目录的时钟，隐藏服务目录只接受时间戳不超过当前时间前三天或后一天的描述符。

   Bob的OP每小时发布一次新的v2描述符，或者在其内容发生变化时发布它。客户可以在给定的24小时内找到V2描述符，在此之后，客户可以按照1.3中描述的方式更改其ID。如果发布的描述符的有效时间小于60分钟(= 2 x 30分钟，允许服务器延迟30分钟，客户机提前30分钟)，Bob的OP将在当前和下一个发布期的ID下发布描述符。

1.5。Alice收到一个z.onion地址。

   当Alice接收到一个指向位置隐藏服务的指针时，它是一个形式为“z.onion”的主机名，其中z是a的base32编码
   Bob的服务公钥的10- 8位哈希值，计算如下:

         1. 令H = H(PK)
         2. 设H' = H的前80位，考虑从最高有效位到最低有效位的每个八位元。
         3.使用RFC 4648中定义的base32生成一个16字符编码的H'。
 (我们只使用80位，而不是SHA1的160位，因为我们不需要担心任意冲突，因为它将使处理url更方便。)
 [是的，一开始可以用数字。看到RFC 1123。海里)

1.6。Alice的OP检索服务描述符。

   Alice的OP从v0隐藏服务目录服务器的固定集合和/或所有v2隐藏服务目录的变化子集中获取服务描述符。

   对于0.2.2.1-alpha之前的版本，Alice的OP通过Tor打开一个到目录服务器的流，并对文档'/ Tor /rendezvous/<z>'发出HTTP GET请求，其中'<z>'被替换为如上所述的Bob的公钥编码。(她可能会为此重复使用旧电路。)如果不识别<z>，该目录将响应一个404 HTTP响应，否则将返回Bob最近上传的服务描述符。

   如果Alice的OP收到404响应，它将尝试其他目录服务器，只有在没有服务器识别公钥散列时，查找才会失败。

   在接收到服务描述符后，Alice用与目录服务器使用的相同的进程进行验证，这在前面的1.4节中描述过。

   如果目录服务器不能理解Alice的请求，它将给出一个400响应。

   Alice应该在本地缓存描述符，但是不应该使用比它们的时间戳早24小时的描述符。[缓存可能使她的分区，但她获取匿名，我们不能很好地*不*缓存它。rd)

   如果Alice的OP运行的是0.2.1.10 alpha或更高，它将获取v2隐藏服务描述符。在0.2.2.1-alpha之前的版本同时获取v0和v2描述符。与第1.4条的描述相似，
   Alice的OP从6个不断变化的节点子集中随机选择的隐藏服务目录中获取v2描述符。如果请求不成功，Alice将按随机顺序重试其他负责隐藏的服务目录。Alice依赖于Bob通过可能存储两组描述符来关心两者之间的潜在时钟偏差(见1.4节末尾)。

   Alice的OP通过Tor打开一个流，指向所选的v2隐藏服务目录。(她可能会为此重复使用旧电路。)在这条小溪,
   Alice的OP对文档“/tor/rendezvous2/<z>”发出HTTP 'GET'请求，其中z被替换为描述符ID的编码。如果它不能识别<z>，该目录将响应一个404 HTTP响应，否则返回Bob最近上传的服务描述符。

1.7。爱丽丝的任务建立了一个集合点。

   当Alice请求连接到一个给定的位置隐藏服务，而Alice的OP没有到该服务的已建立的线路时，OP构建一个会合线路。它通过建立一个电路来随机选择OR，然后发送a
   RELAY_COMMAND_ESTABLISH_RENDEZVOUS单元格到那个或。该细胞的主体包含:

        RC交会cookie[20八位元]

   约会cookie是一个任意的20字节值，随机选择
   Alice应该为每次新的连接尝试选择一个新的约会cookie。

   在接收RELAY_COMMAND_ESTABLISH_RENDEZVOUS单元，或与发送它的电路RC关联。它回答爱丽丝一个空
   RELAY_COMMAND_RENDEZVOUS_ESTABLISHED单元格表示成功。

   Alice的OP不能将发送单元的电路用于任何目的，除了与指定位置隐藏服务会合。

1.8。简介:从Alice的OP到介绍点

   Alice建立了一个单独的电路到Bob选择的一个引入点，并发送给它一个relay_command_entre1单元，包含:

       明文
          PK_ID为Bob的PK[20八进制]的标识符
       加密到Bob的PK:(在v0介绍协议中)
          RP会合点的昵称[20 octets]
          RC Rendezvous cookie [20 octets] g^x diffi - hellman数据，第1部分[128 octets]
        或(在v1 intro协议中)
          VER版本字节:设置为1。[1八隅体]
          RP会合点nick或ID [42 octets]
          RC Rendezvous cookie [20 octets] g^x diffi - hellman数据，第1部分[128 octets]
        或者(在v2介绍协议中)
          VER版本字节:设置为2。[1八隅体]
          IP集合点地址[4个八进制]
          端口集合点或端口[2八字节]
          集合点ID [20 octets]
          洋葱键的KLEN长度[2八进制]
          洋葱匙[九龙八字匙]
          RC Rendezvous cookie [20 octets] g^x diffi - hellman数据，第1部分[128 octets]
        或者(在v3介绍协议中)
          VER版本字节:设置为3。[1八隅体]
          使用的认证类型[1八位元组]
          如果AUTHT != [00]:
              认证数据的AUTHL长度[2八进制]
              AUTHD Auth数据[变量]
          一个时间戳[4个八进制]
          IP集合点地址[4个八进制]
          端口集合点或端口[2八字节]
          集合点ID [20 octets]
          洋葱键的KLEN长度[2八进制]
          洋葱匙[九龙八字匙]
          RC Rendezvous cookie [20 octets] g^x diffi - hellman数据，第1部分[128 octets]

   PK_ID是Bob的公钥或服务密钥的散列，具体取决于隐藏的服务描述符版本。对于v0描述符，Alice的OP使用Bob的公钥。如果Alice下载了一个v2描述符，她将使用包含的公钥(“service-key”)。

   RP是空填充和终止。在介绍协议的0版本中，RP必须包含一个昵称。在版本1中，它必须包含昵称或标识键摘要，用十六进制编码，并以“$”作为前缀。

   Bob的PK的混合加密的工作原理与CREATE cell中的混合加密类似(请参阅tor规范，第0.4节)。因此，线路上版本0 relay_command_introduction e1单元的有效负载将包含20+42+16+20+20+128=246字节，并且版本1和版本2的引入格式具有其他大小。

   通过Tor 0.2.0.6-alpha，客户端只生成v0引入格式，而隐藏服务从0.1.1.x开始就理解并接受v0、v1和v2。在Tor 0.2.0.7-alpha和0.1.2.18中，客户端切换到使用v2介绍格式。

   在Tor 0.2.3.9-alpha和以后的版本中不再使用Timestampe (TS)字段。客户可能不发送它;参见dir-spec.txt中的“Support022HiddenServices”参数。客户应
   不发送一个精确的时间戳，而是应该四舍五入到最近
   10分钟。

1.9。介绍:从介绍点到Bob的OP

   如果引入点识别出PK_ID是一个公共密钥，它为上面1.2中所述的引入建立了一个电路，那么它将在一个新的relay_command_introductions e2单元中的单元体发送到相应的电路中。(如果PK_ID无法识别，则将丢弃relay_command_entre1单元格。)

   将relay_command_introductions单元格发送到Bob后，OR将对
   带有空relay_command_introe_ack单元格的Alice。如果没有
   relay_command_introe2单元格可以发送，OR回答Alice一个非空的单元格，以指示一个错误。(细胞体的语义可以稍后确定;当前实现在失败时发送一个'1'字节。

   当Bob的OP接收到relay_command_introe2单元格时，它首先检查是否重播。由于遗留的混合加密算法具有(不希望看到的!)延展性，Bob的OP应该只检查rsa加密的部分是否被重播。它通过为每个引入密钥保存所有密钥的加密摘要列表来实现这一点
   它看到的导入e2单元的rsa加密部分，并删除以前看到过其rsa加密部分的导入e2单元。当Bob的OP停止使用给定的引入密钥时，它将删除与该密钥对应的重播缓存。
 (在0.2.3.9-alpha之前的Tor版本使用了序言e2单元中的时间戳来限制重播缓存中条目的生存期。这被证明是脆弱的，因为没有充分同步的客户端。)

   假设单元格没有被重放，Bob的服务器用对应隐藏服务的私钥对其进行解密，提取出集合点的昵称、集合cookie以及Alice选择的g^x值。

1.10。会合

   Bob的OP构建了一个新的Tor电路，结束于Alice选择的集合点，并沿着该电路发送RELAY_COMMAND_RENDEZVOUS1单元，包含:

       RC交会cookie[20八字节]g^y Diffie-Hellman[128八字节]
       KH握手文摘[20八位元]
 (Bob的OP不得将此电路用于任何其他目的。)
 (默认情况下，Bob构建的电路至少有三个跳点，*不包括*
   爱丽丝选择的会合点。)

   如果RP识别RC，它在RELAY_COMMAND_RENDEZVOUS2细胞继电器的相应电路的细胞的其余部分，包括:
 g^y Diffie-Hellman[128八元体]
       KH握手文摘[20八位元]
 (如果RP不能识别RC，它会丢弃cell并断开电路。)

   集合点运行Tor版本0.2.9.1-alpha和以后，只要它们包含至少20字节的cookie，就愿意传递集合2单元格。在0.2.9.1-alpha之前，如果单元的有效载荷长度与20+128+20不同，RP将拒绝该单元。

   当爱丽丝的OP收到RELAY_COMMAND_RENDEZVOUS2单元电路使得RELAY_COMMAND_ESTABLISH_RENDEZVOUS细胞但未收到回复,它使用g ^ y和H (g ^ xy)完成握手的Tor电路扩展过程:他们建立60-octet字符串

       K = SHA1 (g ^ xy | [00]) | SHA1 (g ^ xy | [01]) | SHA1 (g ^ xy | [02])
 并生成KH、Df、Db、Kf和Kb，就像tor-spec.txt中记录的KDF-TOR密钥派生方法一样。

   在轻拍握手中，如果从KDF-Tor派生的KH值不匹配在RENDEZVOUS2单元的值，客户端必须关闭电路。

   随后，会合点通过中继单元，不改变，从两个电路的每一个到另一个。当Alice的OP沿电路发送中继单元时，它使用Df进行身份验证，并使用
   Kf，然后是Alice这边的所有的ORs键;当Alice的OP从电路接收到中继单元时，它用Alice这边电路中的ORs的密钥解密它们，然后用Kb解密它们，并检查Db的完整性。Bob的OP也做同样的事情，只是交换了Kf和Kb。

1.11。创建流

   为了打开到Bob的位置隐藏服务的TCP连接，Alice的OP使用特殊地址“”和选择的端口沿着已建立的电路发送RELAY_COMMAND_BEGIN单元格。Bob的OP根据连接到电路的服务的配置选择一个目标IP和端口，并打开一个TCP流。从那时起，Bob的OP将流视为普通的出口连接。[但他不包括addr在连接单元或端单元。rd)

   Alice可以沿着电路发送多个RELAY_COMMAND_BEGIN单元格，以向Bob打开多个流。Alice不应该将电路中任何其他地址的RELAY_COMMAND_BEGIN单元格发送给Bob;如果她这样做了，鲍勃必须拒绝。

1.12。关闭流

   RELAY_END单元格的有效负载以一个描述流为什么关闭的“原因”字节开头，外加可选数据(取决于原因)。这些可以在tor规范的6.3节中找到。下面介绍一些隐藏服务的相关原因。

       1——REASON_MISC

       以未列明的原因来捕获所有信息。在实践中不应该发生太多。

       2——REASON_RESOLVEFAILED

       Tor试图从hsdirs中获取隐藏的服务描述符，但它们都没有。这意味着隐藏服务在过去24小时内没有运行。

       3, REASON_CONNECTREFUSED

       集合的每一步都工作得很好，而且隐藏服务确实已经启动并配置为使用您请求的虚拟端口，但是在虚拟端口的另一端没有侦听任何内容。例如，HS的Tor客户端运行良好，但是它的apache服务宕机了。

       4——REASON_EXITPOLICY

       您尝试的目标端口没有在隐藏服务端配置。也就是说，隐藏的服务是可用的，但是它没有监听这个端口。因为Tor 0.2.6.2 alpha和以后的隐藏服务不发送这个错误代码;相反，他们返回一个
       结束细胞与理性做理性，然后关闭电路在你。这种行为可以通过配置选项来控制。

       5, REASON_DESTROY

       电路在你得到响应之前就关闭了——瞬态故障，例如继电器意外停机。再试一次可能会奏效。

       6——REASON_DONE

       匿名TCP连接被关闭。如果你得到一个末端单元，在你得到你的连接单元之前，这表明一个类似的情况EXITPOLICY，但隐藏服务运行的是0.2.6.2 alpha或更高，它现在已经关闭了你的电路。

       7, REASON_TIMEOUT

       要么像上面的connectrefuse一样，但是connect()得到了ETIMEDOUT errno，要么客户端超时120秒，我们放弃了。

       8——REASON_NOROUTE

       类似于connectrefuse，除了当尝试连接()到服务时隐藏服务的errno是ENETUNREACH, EHOSTUNREACH，
       EACCES或EPERM。

       10——REASON_INTERNAL

       Tor客户端内部错误——希望您不会看到太多。如果有，请报告!

       12——REASON_CONNRESET

       类似connectrefuse，除了当试图连接()到服务时隐藏服务的errno被ECONNRESET。

2. 身份验证和授权。

   第1节中描述的rendezvous协议提供了一些用于实现客户端授权的选项。在集合协议中有两个步骤可用于执行客户端授权:在下载和解密隐藏服务描述符的部分时，以及在Bob的Tor客户端与集合点接触之前。服务提供商可以在这两点将其服务的访问限制为仅允许授权客户访问。

   目前指定了两种授权协议，具体描述如下:

    1. 第一个协议允许服务提供者仅限制对使用先前接收到的密钥的客户端的访问，但不试图对其他人隐藏服务活动。

    2. 第二种方案，虽然是可行的有限集左右
       客户端，执行客户端授权并对除了授权客户端以外的所有人隐藏服务活动。

2.1。具有大规模客户授权的服务

   第一个客户机授权协议旨在执行访问控制，同时尽可能少地消耗额外资源。这是“基本”授权协议。服务提供者应该能够允许对大量客户机的访问，同时拒绝其他所有人的访问。
   然而，可伸缩性的代价是服务无法对未经授权或以前授权的客户机隐藏其活动。

   该协议的主要思想是使用对称密钥将隐藏服务描述符中的引入点部分加密到授权客户端。
   这确保了除了授权客户端以外，没有其他人可以了解服务当前使用的介绍点，也不能在不知道介绍键的情况下发送有效的介绍e1消息。因此，不需要在引入点进行后续授权。

   服务提供者为他的客户端生成对称的“描述符cookie”，并在Tor外部分发它们。建议的键大小为
   128位，这样描述符cookie可以被编码为22个base64位字符(最多可以容纳22 * 6 = 132位，留下4位对授权类型进行编码(这里是“0”)，并允许客户端将此授权协议与下面提出的其他协议区别开来)。
   通常，使用此授权协议的隐藏服务的联系信息如下:
 v2cbb2l4lsnpio4q。洋葱Ll3X7Xgz9eHGKCCnlFH0uz

   在生成隐藏服务描述符时，服务使用一个随机生成的对称加密导入点部分
   按照rend-spec中v2隐藏服务描述符的描述，使用AES-CTR的128位会话密钥。然后，服务使用AES将会话密钥加密到所有描述符cookie。授权客户端应该能够有效地找到为其加密的会话密钥，从而生成由描述符cookie和初始化向量组成的4个8字节长的客户端ID。描述符总是包含许多加密的会话密钥，通过添加假条目，这些密钥是16的倍数。
   加密会话密钥根据客户端id排序，以隐藏服务提供商添加或删除授权客户端。

     授权类型:设置为1。[1八隅体]
     客户端总数:= 1 +((客户端- 1)div 16)[1八位组]
 对于每个对称描述符cookie:

     客户端ID: H(描述符cookie | IV)[:4] [4 octets]
     使用描述符cookie加密的SKEY会话密钥[16八进制]
 (客户端专用部分)

     RND随机数据[(15 -((客户端- 1)mod 16)) * 20 octets]
     IV AES初始化向量[16八字节]
     ipo介绍点，使用会话密钥加密[剩余八进制]

   授权客户端需要配置Tor在访问隐藏服务时使用描述符cookie。因此，用户将从服务提供者那里收到的联系信息添加到她的torrc文件中。在下载隐藏的服务描述符时，Tor会找到加密的导入点部分，并尝试使用配置的描述符cookie对其解密。(在两个或两个以上病人的罕见情况下)
   id等于客户端试图解密所有id。)

   在发送介绍时，客户端在她发送给服务的介绍e2单元格中包括她的描述符cookie，作为身份验证类型“1”。
   隐藏服务检查包含的描述符cookie是否被授权访问服务，是否响应引入请求。

2.2。有限数量的客户的授权

   第二种更复杂的客户端授权协议可以对未经授权的客户端隐藏服务活动。这是“秘密”授权协议。如果其他所有内容都与前面的授权协议相同，则第二个协议分别为每个用户发布隐藏的服务描述符，并将描述符的导入点部分加密到单个客户端。这允许服务停止发布已删除客户端的描述符。只要已删除的客户端不能将为其他客户端发出的描述符链接到该服务，它就不能再派生服务活动。这种方法的缺点是有限的可伸缩性。尽管描述符的分布式存储(cf. proposal 114)在一定程度上解决了可伸缩性有限的问题，但该协议不应用于客户端超过16个的服务。(事实上，Tor应该拒绝为超过这个数量的客户做广告。)

   隐藏服务为每个客户端生成一个非对称的“客户端密钥”和一个对称的“描述符cookie”。客户端密钥用于替换服务的永久密钥，以便服务为其每个客户端使用不同的标识。描述符cookie用于在更改目录节点时存储描述符，这些目录节点对除服务和客户端之外的任何人都不可预测，用于加密导入点部分，并将其包含在导入e2单元中。一旦服务创建了客户端密钥和描述符cookie，他就会将它们告诉Tor外部的客户端。联系人信息字符串与前面的授权协议使用的字符串类似(唯一的区别是，在剩下的4个132位中，“1”被编码为auth-type，而不是以前的“0”)。

   当为授权客户端创建隐藏服务描述符时，隐藏服务使用客户端密钥和描述符cookie计算秘密ID部分和描述符ID:
 secret-id-part = H(时间段|描述符-cookie |副本)
 描述符-id = H(客户端密钥[:10]|保密id部分)

   隐藏服务还用客户端密钥替换描述符中的永久密钥，用描述符cookie替换加密导入点。

     授权类型:设置为2。[1八隅体]
     IV AES初始化向量[16八字节]
     ipo介绍点，encr。使用描述符cookie[其余八位元]

   在上传描述符时，隐藏服务需要确保不同客户端的描述符不会同时上传(cf。
   第1.1节)，这也是客户数量的限制因素。

   当请求客户机建立到隐藏服务的连接时，它会查找是否为该服务配置了任何授权数据。如果用户已经为授权协议"2"配置了授权数据，则按照最后一段中所述确定描述符ID。在接收到描述符后，客户端使用它的描述符cookie解密导入点部分。此外，客户端在它发送给服务的导入e2单元格中将其描述符cookie包括为authtype "2"。

2.3。隐藏服务配置

   要执行客户端授权的隐藏服务在其隐藏服务配置中添加了一个新选项HiddenServiceAuthorizeClient。此选项包含2.1协议的授权类型为“basic”，2.2协议的授权类型为“隐身”，以及一个逗号分隔的人类可读客户端名称列表，以便Tor可以为这些客户端创建授权数据:

     HiddenServiceAuthorizeClient auth-type客户名字,客户名字,…

   如果配置了此选项，则HiddenServiceVersion将自动重新配置为只包含版本号为2或更高的版本号。有一个最大的512个客户端名称为基本认证和一个最大的16个秘密认证。

   Tor将为第2.1节和2.2节中描述的授权协议生成的所有授权数据存储在一个新文件中，使用以下文件格式:
 “客户端名称”人类可读的客户端标识符“descriptor-cookie”128位密钥^= 22 base64字符NL

   如果使用第2.2节的授权协议，Tor还会生成和存储以下数据:
 “客户端密钥”NL PEM格式的私钥[没有额外参数]

2.4。客户端配置

   要指定用于访问给定隐藏服务的cookie，客户端使用以下语法:

    HidServAuth洋葱地址auth-cookie[服务名称]:

     有效的洋葱地址包含16个字符在a-z2-7加上"。和有效身份验证cookie中包含22个字符
     A-Za-z0-9 + /。服务名称仅用于内部目的，例如，Tor控制器;Tor本身并不需要或使用它。


3.隐藏服务目录操作

   本节介绍了v2隐藏服务描述符格式。它描述了获取v2隐藏服务描述符的所有操作和传播机制，这是第1节中描述的协议成功获取v2隐藏服务描述符所必需的。

3.1。配置为隐藏服务目录

   每个打开目录端口的洋葱路由器都可以决定是否要存储和提供隐藏的服务描述符。这样配置的洋葱路由器在它发送给目录权威机构的路由器描述符中包含“hidden-service-dir”标志。

   目录权限包括一个新的标志“HSDir”，用于决定为隐藏服务描述符提供存储并且已经运行了至少96个小时的路由器。

3.2。接受发布请求

   隐藏服务目录节点接受v2隐藏服务描述符的发布请求，并将它们存储到本地内存中。(没有必要让描述符持久，因为重新启动后，洋葱路由器无论如何都不会被接受为存储节点，因为它至少没有运行24小时。)所有的请求和回复都格式化为
   HTTP消息。请求通过指向路由器目录端口的BEGIN_DIR单元发起，并格式化为HTTP POST请求到相对于隐藏服务目录根的URL“/tor/rendezvous2/publish”，作为它的主体包含一个v2服务描述符。

   隐藏服务目录节点解析每个接收到的描述符，并且仅当它认为自己有责任根据自己的路由表存储描述符时才存储它。有关如何确定某个描述符ID的职责的更多信息，请参见第1.4节。

3.3。处理获取请求

   隐藏服务目录节点通过在其本地内存中查找隐藏服务描述符来处理获取请求。(他们不需要确定他们是否对传递的ID负责，因为如果他们交付了一个他们(不再)负责的描述符，这不会造成任何伤害。)
   所有的请求和响应都被格式化为HTTP消息。请求通过指向路由器的目录端口的BEGIN_DIR单元格发起，并格式化为HTTP获取文件“/tor/rendezvous2/<z>”的请求，其中z被替换为编码的描述符ID。

