

                         Tor协议规范

                              罗杰Dingledine
                               尼克·马修森

注意:本文档旨在将Tor指定为当前实现的，尽管它可能需要一点时间才能完全跟上最新的情况。Tor的未来版本可能会实现改进的协议，但不能保证兼容性。
我们可以也可以不删除其他过时版本的兼容性说明
Tor是过时的。

本规范不是设计文档;大多数设计标准没有被检查。有关Tor为什么这样做的更多信息，请参阅Tor -design.pdf。

0. 预赛

      “必须”、“不得”、“必须”、“应当”、“应当”等关键词
      本文档中的“不”、“应该”、“不应该”、“推荐”、“可能”和“可选”将按照中描述的方式解释
      RFC 2119。

0.1。符号和编码

   PK——一个公钥。
   SK——私钥。
   K——对称密码的密钥。
 a|b, a和b的连接。
 [A0 B1 C2]——一个三字节序列，按顺序包含十六进制值为A0、B1和C2的字节。

   H(m)——m的加密哈希。

   我们可以互换使用“字节”和“八字节”。可能我们不应该。

0.1.1。编码整数

   除非我们在下面明确地另有说明，否则所有的数值在
   Tor协议是按网络(大端)顺序编码的。所以“32位整数”意味着一个32位的大端整数;一个“2字节”整数意味着一个16位的大端整数，以此类推。

0.2。安全参数

   Tor使用一个流密码、一个公钥密码、Diffie-Hellman协议和一个哈希函数。

   KEY_LEN——流密码的密钥长度，以字节为单位。

   PK_ENC_LEN——公开密匙加密消息的长度，以字节为单位。
   PK_PAD_LEN——为公钥加密添加的填充字节数，以字节为单位。(因此，在单个公钥操作中可以加密的最大字节数是PK_ENC_LEN-PK_PAD_LEN。)

   的成员的字节数
     diffie - hellman组。
   DH_SEC_LEN——Diffie-Hellman私钥(x)中使用的字节数。

   HASH_LEN——哈希函数输出的长度，以字节为单位。

   PAYLOAD_LEN——允许的最长单元有效负载，以字节为单位。(509)

   CELL_LEN(v)——连接协议版本v的Tor单元的长度，以字节为单位。
       如果v小于4，则CELL_LEN(v) = 512;= 514。

0.3。密码

   这些是我们使用的密码，除非另有规定。其中一些已被弃用作新用途。

   对于流密码，除非另有指定，否则我们在计数器模式中使用128位AES，其IV为所有0字节。(我们还需要AES256。)

   对于公钥密码，除非另有说明，我们使用RSA
   1024位键和固定的指数65537。我们使用OAEP-MGF1垫料，SHA-1作为其摘要函数。我们没有设置可选的“Label”参数。(有关OAEP填充，请参阅ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf)

   我们还在几个地方使用Curve25519组和Ed25519签名格式。

   对于Diffie-Hellman，除非另有说明，我们使用2的生成器(g)。对于模(p)，我们使用rfc2409章节6.2中的1024位安全素数，其十六进制表示为:
 “ffffffffffffffffffffffffffffc90fdaa22168c234c6628b80dc1cd129024e08”“8a67cc74020bbea63b139b22514a08798e3406d6d51c245c245e485b576625e7ec6f44c42e9”“a637ed6b0bff5cb6f406b7e386bb5a899fa5ae9f24117c4b1fe6”

   作为优化，实现应选择DH私钥(x)的
   320位。这样做的实现不能使用任何DH键超过一次。[其他实现是否可以重用他们的DH密钥??rd][可能不是。可以想象，您可以通过每秒更改一次DH键来逃避，但对于我来说，有太多奇怪的攻击，这是安全的。海里)

   对于哈希函数，除非另有说明，我们使用SHA-1。

   KEY_LEN = 16。
   DH_LEN = 128;DH_SEC_LEN = 40。
   PK_ENC_LEN = 128;PK_PAD_LEN = 42。
   HASH_LEN = 20。

   我们也在一些地方使用SHA256和SHA3-256。

   当我们提到“公钥的散列”时，除非另有说明，我们指的是ASN.1 RSA公钥的DER编码的SHA-1散列(在PKCS.1中指定)。

   除非另有说明，否则所有的“随机”值必须由一个加密的强伪随机数生成器生成。

0.4。一个坏的混合加密算法，为遗留目的。

   一些规范将对公钥PK的字节序列M进行“遗留混合加密”，计算方法如下:

      1. 如果M的长度不超过PK_ENC_LEN-PK_PAD_LEN, pad并用PK加密M。
      2. 否则，生成KEY_LEN字节随机密钥K。
         令M1 = M的第一个PK_ENC_LEN-PK_PAD_LEN-KEY_LEN字节，令M2 = M的其余部分。
         用PK加密K|M1，用我们的流密码加密M2，使用密钥K。将这些加密的值连接起来。

   请注意，这种“混合加密”方法并不能阻止攻击者在m的末尾添加或删除字节，它还允许攻击者修改OAEP中没有涉及到的字节——请参阅Goldberg的PET2006论文以获得详细信息。不要使用它作为新的协议的基础!还要注意的是，正如在Tor协议中使用的那样，情况1从未发生过。

1. 系统概述

   Tor是一种分布式覆盖网络，设计用于匿名化基于tcp的低延迟应用程序，如web浏览、安全shell和即时消息传递。客户端通过网络选择一条路径并构建一个电路，其中路径中的每个节点(或洋葱路由器或)知道它的前任和继任者，但电路中的其他节点不知道。沿着电路流动的流量以固定大小的“单元”的形式发送，这些单元在每个节点(就像洋葱的层)被一个对称密钥解开，然后向下转发。

1.1。键和名字

   每个Tor中继有多个公钥/私钥对:

   这些是1024位的RSA密钥:

    -只可签署文件及证书的长期“身分密码匙”，并用以确立中继身分。
    -一个中期点击“洋葱键”，用于在接受电路扩展尝试时解密洋葱皮。(参见5.1)。旧的密钥在不再做广告后必须接受一段时间。因此，继电器在旋转后必须保留旧键一段时间。(参见diro -spec.txt中的“洋葱键寿命参数”。)
    -用于协商TLS连接的短期“连接键”。
      Tor实现可以随心所欲地旋转这个键
      每天至少要转动这把钥匙一次。

   这是Curve25519键:

    -一个中期ntor“洋葱键”，用于处理洋葱键握手时接受传入电路扩展请求。与点击洋葱键一样，旧的ntor键必须在不再做广告后至少一周内被接受。因此，继电器在旋转后必须保留旧键一段时间。(参见diro -spec.txt中的“洋葱键寿命参数”。)

   这些是Ed25519键:

    -长期的“主身份”密钥。这把钥匙永不改变;它仅用于对下面的“签名”键进行签名。它可以保持离线状态。
    -中期“签署”关键。此密钥由主身份密钥签名，必须保持在线。应该定期生成一个新的。它几乎标志着所有的东西。
    -一个短期的“链路认证”密钥，用于验证链路握手:见下文第4节。此密钥由“签名”密钥签名，应该经常重新生成。

   RSA标识密钥和Ed25519主标识密钥一起唯一地标识路由器。一旦路由器将Ed25519主身份密钥与给定的RSA身份密钥一起使用，这些密钥就不能与不同的密钥一起使用。

2. 连接

   两个Tor继电器之间，或者一个客户端和一个继电器之间的连接，使用TLS/SSLv3进行链接认证和加密。所有实现都必须支持可用的SSLv3密码套件“TLS_DHE_RSA_WITH_AES_128_CBC_SHA”。如果可以的话，它们应该支持更好的密码套件。

   有三种方法可以在Tor服务器上执行TLS握手。第一种方式是“证书预先”，发起者和响应者都发送一个两证书链作为初始握手的一部分。(所有Tor版本都支持此功能。)第二种方式是“重新协商”，响应方提供单个证书，启动方立即执行TLS重新协商。(这在Tor 0.2.0.21及以后版本中得到支持。)第三种方式是“协议内”，初始的TLS协商完成后，双方通过使用
   Tor协议没有进一步的TLS握手。这是支持的
   0.2.3.6-alpha之后)。

   这些选项中的每一个都为各方提供了一种了解它可用的方法:客户端不需要知道Tor服务器的版本才能正确连接到它。

   在“证书预先”(又名“v1握手”)中，连接启动程序总是发送一个双证书链，包括一个使用短期连接公钥的X.509证书和一个包含其身份密钥的自签名X.509证书。另一方发送一个类似的证书链。发起者的ClientHello不能包含任何密码套件，除了:

     TLS_DHE_RSA_WITH_AES_256_CBC_SHA
     TLS_DHE_RSA_WITH_AES_128_CBC_SHA
     SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA

   在“重新谈判”。“v2握手”)，连接启动程序不发送任何证书，而响应程序发送单个连接证书。TLS握手完成后，发起者重新协商握手，双方发送一个双证书链，如“证书预先”。
   启动程序的ClientHello必须包含至少一个不在上面列表中的密码套件——这是启动程序指示它可以处理此握手的方式。有关启动程序的其他考虑事项
   ClientHello，见下面第2.1节。

   “在协议”(或称。“v3握手”)，启动程序不发送任何证书，响应程序发送单个连接证书。密码套件的选择必须与“重新协商”握手时一样。连接证书上还有一组约束，发起者可以使用这些约束了解协议内握手正在使用中。具体地说，证书的这些属性中至少有一个必须为真:

      *证书是自签名的
      *在证书的主题或颁发者DN中设置了除“commonName”以外的其他组件。
      *证书的主体或签发者的通用名称以除"。net"以外的后缀结尾。
      *证书的公钥模量超过1024位。

   发起者然后向响应者发送版本单元格，响应者随后用版本单元格进行响应;然后他们协商了Tor协议的版本。假设它们协商的版本是3或更高版本(目前为此握手指定的唯一版本)，响应程序将发送一个CERTS单元、一个AUTH_CHALLENGE单元和一个NETINFO单元给发起者，发起者可以发送一个CERTS、AUTHENTICATE、
   如果需要认证，请使用NETINFO;如果不需要认证，请使用NETINFO。

   为了在以后的握手和“预先的证书”之间实现向后兼容性，支持以后的握手的启动程序的ClientHello必须包括除了上面列出的密码套件之外的至少一个密码套件。连接响应程序检查启动程序的密码套件列表，以查看它是否包括上面列表中所包含的密码以外的任何密码。如果包含额外的密码，响应程序按照“重新协商”和“协议内”的方式进行:它发送单个证书，不请求客户端证书。否则(在ClientHello中没有包含额外的密码套件的情况下)，响应程序将按照“证书预先”的方式进行:它请求客户端证书，并发送一个双证书链。在这两种情况下，一旦响应方发送了它的证书或证书，发起者就会对它们进行计数。如果发送了两个证书，则按照“预先发送证书”的方式进行;否则，将按照“重新协商”或“协议内”进行。

   要决定是执行“重新协商”还是“协议内”，启动程序将检查响应程序的初始证书是否符合上面列出的标准。

   所有新的Tor协议的中继实现必须支持向后兼容的重新协商;客户也应该这样做。如果这是不可能的，新的客户端实现必须支持“重新协商”和“协议内”，并使用路由器的发布链接协议列表(参见“协议”条目中的dir-spec.txt)来决定使用哪一个。

   在上述所有握手变体中，以清除方式发送的证书
   不应该包括任何字符串来标识主机作为Tor中继。在“重新协商”和“向后兼容的重新协商”步骤中，启动程序应该选择一组密码套件和TLS扩展，以模拟流行的web浏览器所使用的密码套件和TLS扩展。

   即使连接协议是相同的，如果发起者愿意为其他Tor用户中继通信，我们将把它看作一个洋葱路由器(或)，或者如果它只处理本地请求，我们将把它看作一个洋葱代理(OP)。洋葱代理不应该提供长期跟踪标识符在他们的握手。

   在所有握手变体中，一旦交换了所有证书，所有接收证书的各方都必须确认身份密钥符合预期。如果密钥不符合预期，则各方必须关闭连接。
 (在初始化连接时，如果有一个合理的活动一致，则从该一致中获取预期的标识密钥。但是，在以其他方式初始化连接时，预期的标识密钥是硬编码的权限或回退列表中给出的密钥。最后，当创建连接时，由于
   扩展/扩展d2单元，预期的标识键是单元中给定的那个。)

   当连接到OR时，所有各方都应该拒绝连接
   或有一个畸形或丢失的证书。当接受一个传入连接时，OR不应该拒绝来自格式错误或缺少证书的一方的传入连接。(但是，OR不应该认为传入的连接来自另一个连接，除非存在证书且格式良好。)
 在版本0.1.2.8-rc之前，ORs拒绝来自ORs和的传入连接
   如果他们的证书丢失或格式不正确的话，OPs也一样。

   一旦建立了TLS连接，双方互相发送单元格(下面指定)。单元格是连续发送的。标准单元格是CELL_LEN(link_proto)字节长，但也存在可变长度的单元格;看到第三节。单元可以被发送嵌入在任何大小的TLS记录或跨TLS记录划分，但是TLS记录的帧不能泄漏关于单元的类型或内容的信息。

   TLS连接不是永久的。任何一方可以关闭一个连接，如果没有电路运行在它和时间的数量(KeepalivePeriod，默认为5分钟)已经经过了最后一次任何流量传输通过TLS连接。客户端也应该保持一个没有打开电路的TLS连接，如果有可能很快就会使用该连接建立一个电路的话。

   如果那些证书为它们所接触的中继提供了任何持久性标记，那么鼓励仅客户机的Tor实例避免使用包含证书的握手变体。如果客户端使用证书，他们不应该继续使用相同的证书时，他们的IP地址改变。客户端可以使用以上任何一种握手变体发送证书。

2.1。挑选TLS密码套件

   客户端应该发送一个密码套件列表，选择它来模拟一些流行的web浏览器或internet上常见的其他程序。客户端可以发送下面的“固定密码列表”。如果不支持，就不能发布任何他们实际上不能支持的密码套件，除非OpenSSL 1.0.1不支持该密码。

   固定的密文套件列表为:

     TLS1_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
     TLS1_ECDHE_RSA_WITH_AES_256_CBC_SHA
     TLS1_DHE_RSA_WITH_AES_256_SHA
     TLS1_DHE_DSS_WITH_AES_256_SHA
     TLS1_ECDH_RSA_WITH_AES_256_CBC_SHA
     TLS1_ECDH_ECDSA_WITH_AES_256_CBC_SHA
     TLS1_RSA_WITH_AES_256_SHA
     TLS1_ECDHE_ECDSA_WITH_RC4_128_SHA
     TLS1_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
     TLS1_ECDHE_RSA_WITH_RC4_128_SHA
     TLS1_ECDHE_RSA_WITH_AES_128_CBC_SHA
     TLS1_DHE_RSA_WITH_AES_128_SHA
     TLS1_DHE_DSS_WITH_AES_128_SHA
     TLS1_ECDH_RSA_WITH_RC4_128_SHA
     TLS1_ECDH_RSA_WITH_AES_128_CBC_SHA
     TLS1_ECDH_ECDSA_WITH_RC4_128_SHA
     TLS1_ECDH_ECDSA_WITH_AES_128_CBC_SHA
     SSL3_RSA_RC4_128_MD5
     SSL3_RSA_RC4_128_SHA
     TLS1_RSA_WITH_AES_128_SHA
     TLS1_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA
     TLS1_ECDHE_RSA_WITH_DES_192_CBC3_SHA
     SSL3_EDH_RSA_DES_192_CBC3_SHA
     SSL3_EDH_DSS_DES_192_CBC3_SHA
     TLS1_ECDH_RSA_WITH_DES_192_CBC3_SHA
     TLS1_ECDH_ECDSA_WITH_DES_192_CBC3_SHA
     SSL3_RSA_FIPS_WITH_3DES_EDE_CBC_SHA
     SSL3_RSA_DES_192_CBC3_SHA[*]在检查密码套件列表时，不计算“支持扩展的重新协商”密码套件0x00ff。

   如果客户端发送固定的密码套件列表，那么响应者必须不选择TLS_DHE_RSA_WITH_AES_256_CBC_SHA之外的任何密码套件，
   TLS_DHE_RSA_WITH_AES_128_CBC_SHA和SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA:客户机可能实际上不支持这样的密码。

   如果客户端发送一个v2+ ClientHello和一个加密列表，而不是固定的密码套件列表，那么响应者就可以相信客户端支持该列表中提到的所有密码，只要该密码套件也被OpenSSL 1.0.1所支持。

   响应器不能选择任何缺少临时键、对称键小于KEY_LEN位或摘要小于HASH_LEN位的TLS密码套件。除了上面列出的DHE+3DES套件之外，应答器不应该选择任何SSLv3密码套件。

2.2。TLS安全注意事项

   实现一定不能允许TLS会话恢复——它会加剧一些攻击(例如，来自
   (2013年2月2日)，它严重破坏了前向保密保证。

   实现不应该允许TLS压缩——尽管我们不知道如何将犯罪风格的攻击直接应用到当前的Tor，但这是一种资源浪费。

3.电池包格式

   洋葱路由器和洋葱代理的基本通信单元是一个固定宽度的“单元”。

   在version 1连接上，每个单元包含以下字段:

        CircID                                 [ CIRCID_LEN字节)
        命令                                [ 1字节)
        有效负载(用填充字节填充)[PAYLOAD_LEN字节]

   在版本2或更高版本的连接中，除了可变长度单元格之外，所有单元格都与版本1中的连接相同，其格式为:

        CircID                                 [ CIRCID_LEN八位字节)
        命令                                [ 1八隅体]
        长度                                 [ 2八位字节;大端法整数)
        有效载荷(一些命令可能会垫)[长度字节]

   大多数可变长度单元格可以用填充字节填充，版本单元格除外，版本单元格必须不包含任何额外的字节。(填充单元格的有效载荷由填充字节组成。)

   在version 2连接上，可变长度单元格由等于7的命令字节表示(“VERSIONS”)。在版本3或更高版本的连接上，可变长度单元由等于7 ("VERSIONS")或大于或等于128的命令字节表示。

   对于链接协议版本1、2和3,CIRCID_LEN是2。对于版本4或更高的链路协议，CIRCID_LEN是4。第一个版本单元格和在第一个版本单元格之前发送的任何单元格始终具有
   CIRCID_LEN == 2表示向后兼容性。

   CircID场决定了细胞与哪个电路(如果有的话)相关联。

   固定长度单元格的“Command”字段包含以下值之一:

         0——填充(填充)(参见7.2节)
         1——创建(创建电路)(参见5.1节)
         2——创建(确认创建)(见第5.1节)
         3——继电器(端到端数据)(见第5.5和6节)
         4—破坏(停止使用电路)(参见5.4节)
         5——CREATE_FAST(创建电路，无PK)(见第5.1节)
         6—CREATED_FAST(电路已创建，无PK)(见第5.1节)
         8——NETINFO(时间和地址信息)(见第4.5节)
         9——RELAY_EARLY(端到端数据;有限公司)(见5.6秒)
         10——CREATE2(扩展的创建单元格)(参见5.1节)
         11——CREATED2(扩展创建单元)(参见5.1节)
         12——PADDING_NEGOTIATE(填充协商)(参见第7.2节)

    可变长度的命令值为:

         7—版本(协商原型版本)(见第4节)
         128——可变长度填充(见7.2节)
         129——CERTS(证书)(见第4.2节)
         130——AUTH_CHALLENGE(质疑值)(参见第4.3节)
         131——身份验证(客户端身份验证)(参见第4.5节)
         132——授权(客户授权)(未使用)

   “有效载荷”的解释取决于单元格的类型。

      VPADDING /填充:
               有效负载包含填充字节。
      CREATE/CREATE2:有效负载包含握手挑战。
      CREATED/CREATED2:有效负载包含握手响应。
      中继/RELAY_EARLY:有效负载包含中继头和中继主体。
      摧毁:有效载荷包含关闭电路的原因。(见5.4)

   当接收到命令字段的任何其他值时，OR必须删除该单元格。因为将来可能会添加更多的单元格类型，所以当遇到无法识别的命令时，ORs通常不应该发出警告。

   用填充字节将单元格填充到单元格长度。

   发送者根据单元格的命令设置填充字节:

      版本:有效负载不能包含填充字节。
      授权:有效负载是未指定的，并保留为将来使用。
      其他的变长细胞:
                 有效负载可以在单元格的末尾包含填充字节。
                 填充字节应该设置为NUL。
      RELAY/RELAY_EARLY:有效负载必须用填充字节填充到PAYLOAD_LEN。填充字节应该设置为随机值。
      其他固定长度的细胞:
                 有效负载必须用填充字节填充到PAYLOAD_LEN。
                 填充字节应该设置为NUL。

   我们建议在RELAY/RELAY_EARLY单元格中随机填充，这样单元格内容是不可预测的。继电器单元的格式详见6.1节。

   对于其他单元格，TLS对单元格内容进行身份验证，因此随机填充字节是多余的。

   接收方必须忽略填充字节。

   填充单元格目前用于实现连接保持活动状态。
   如果没有其他通信，ORs和OPs每隔几分钟互相发送一个填充单元。

   CREATE, CREATE2, CREATE, CREATED2，和DESTROY单元用于管理电路;参见下面的第5节。

   中继单元用来沿电路发送命令和数据;见下文第6节。

   版本和NETINFO单元用于在v2或更高的链路协议中建立连接;在链路协议v3及更高版本中，
   也可以使用AUTH_CHALLENGE和AUTHENTICATE。参见下面的第4节。

4. 协商和初始化连接

   在Tor实例通过“重新协商”或“协议内”握手进行协商后，它们必须交换一组单元来建立Tor连接，并使其“开放”并可用于电路。

   当使用重新协商握手时，双方立即发送一个版本单元(下面4.1)，在协商一个链接协议版本(将是2)之后，双方分别发送一个NETINFO单元(下面4.5)来确认它们的地址和时间戳。不允许其他介入细胞类型。

   当使用协议内握手时，发起者发送
   版本单元格，表示它不会重新协商。响应方发送一个版本单元，一个CERTS单元(下面4.2)给发起者它需要的证书来学习响应方的身份，一个AUTH_CHALLENGE单元(4.3)，如果它选择认证，发起者必须将其作为答案的一部分，以及一个NETINFO单元(4.5)。一旦获得CERTS单元，启动程序就知道响应程序是否得到了正确的身份验证。此时，根据是否希望进行身份验证，启动程序的行为会有所不同。如果它不想进行身份验证，它必须发送一个NETINFO单元格。如果要进行身份验证，则必须发送
   CERTS单元、认证单元(4.4)和NETINFO。使用此握手时，第一个单元格必须是版本、VPADDING或
   授权，并且除了指定的单元格类型外，不允许其他单元格类型干预，VPADDING单元格除外。

   授权单元类型被保留为未来使用的扫描电阻设计。
 在0.2.3.11-alpha之前的Tor版本不识别授权单元，并且不允许任何版本以外的命令作为协议内握手的第一个单元。

4.1。与版本单元协商版本

   有多个Tor链接连接协议的实例。使用“证书预先”握手(参见上面的第2节)协商的任何连接都是“版本1”。在任何双方行为与“重新协商”握手相同的连接中，链接协议版本必须为2。在任何双方行为与“协议内”握手相同的连接中，链路协议必须为3或更高。

   为了确定版本，在使用“重新协商”或“协议内”握手的任何连接中(也就是说，响应方在第一次协商中只发送了一个证书，而发起者在第一次协商中没有发送任何证书)，双方都必须发送一个版本单元。在“重新协商”中，它们在重新协商完成后立即发送版本单元格，在发送任何其他单元格之前。在“协议内”中，初始TLS握手后，发起者立即发送一个版本单元格，响应者立即用版本单元格进行响应。(作为此规则的一个例外，如果双方都支持“协议内”握手，则任何一方都可以发送
   可随时填充单元格。)

   版本单元中的有效负载是一系列大端双字节整数。双方必须选择它们发送的版本单元和它们接收的版本单元中所包含的最大数量作为链接协议版本。如果它们没有相同的版本，它们就不能通信，必须关闭连接。如果版本单元不是格式良好的(例如，如果它包含奇数字节)，则任何一方都必须关闭连接。

   在第一个版本单元格之后发送的任何版本单元格都必须被忽略。(为了正确解释，以后的版本单元格必须有一个CIRCID_LEN来匹配与第一个版本单元格协商的版本。)

   由于版本1链接协议不使用“重新协商”握手，因此实现不能在其版本单元中列出版本1。当使用“重新协商”握手时，实现
   必须只列出版本2。当使用“协议内”握手时，实现不能列出3之前的任何版本，而且应该至少列出3版本。

   链路协议的差异是:

     1——“事前握手”。
     2——使用基于重新协商的握手。介绍了变长细胞。
     3——使用协议内握手。
     4——电路ID宽度增加到4字节。
     5——增加了对链接填充和协商的支持(paddingspec .txt)。


4.2。确实的事情细胞

   CERTS单元描述了Tor实例声称拥有的密钥。它是一个可变长度的单元格。其有效载荷格式为:

        N:单元中cert的数目[1八位元]
        N次:
           CertType                            [ 1八隅体]
           CLEN                                [ 两个八位字节)
           证书                         [ CLEN八位字节)

   必须忽略CERTS单元末尾的任何额外的八位元。

     相关的certType值为:
        1:通过RSA1024身份认证的链接密钥证书
        2: RSA1024身份证明，自签名。
        3: RSA1024认证单元链路证书，用RSA1024密钥签名。
        4: Ed25519签名密钥，用身份密钥签名。
        5: TLS链接证书，使用ed25519签名密钥签名。
        6: Ed25519认证单元密钥，用Ed25519签名密钥签名。
        7: Ed25519身份，用RSA身份签名。

   证书类型1-3的证书格式是DER编码的
   X509。对于其他人，其格式在cert-spec.txt中有文档记录。
   注意，类型7使用的格式与类型4-6不同。

   每个CERTS单元对每种CertType只能有一个证书。


   要验证响应程序具有给定的Ed25519 RSA身份密钥组合，启动程序必须检查以下内容。

     * CERTS单元包含一个CertType 2“ID”证书。
     * CERTS单元包含一个CertType 4 Ed25519“Id->签名”证书。
     * CERTS单元包含一个确切的CertType 5 Ed25519“签名->链接”证书。
     * CERTS单元包含一个CertType 7 "RSA->Ed25519"交叉证书。
     *以上所有X.509证书均在日期之后和日期之前有效;没有X.509或Ed25519证书过期。
     *所有证书均已正确签署。
     *签名->链接证书中的认证密钥与
       SHA256用于对TLS连接进行身份验证的证书摘要。
     *使用ID->签名证书中列出的身份密钥对ID->签名证书进行签名。
     *签名->链接证书使用ID->签名证书中列出的签名密钥进行签名。
     * RSA->Ed25519交叉证书证明Ed25519身份，并使用“ID”证书中列出的RSA身份签名。
     * ID证书中的认证密钥为1024位RSA密钥。
     * RSA ID证书已正确自签名。

   要验证响应程序只有给定的RSA身份，启动程序必须检查以下内容:

     * CERTS单元包含一个CertType 1“Link”证书。
     * CERTS单元包含一个CertType 2“ID”证书。
     *两个证书都有过期后有效和未过期前有效。
     *链接证书中的认证密钥与用于协商TLS连接的链接密钥相匹配。
     * ID证书中的认证密钥为1024位RSA密钥。
     * ID证书中的认证密钥用于签署两个证书。
     中的密钥正确地签署了链接证书
       ID证书
     * ID证书已正确自签名。

   在上述两种情况下，检查这些条件就足以验证启动程序是否使用ID证书中认证的预期标识与Tor节点通信。


   为了验证发起人拥有给定的Ed25519,RSA身份密钥组合，响应者必须检查以下内容:

     * CERTS单元包含一个CertType 2“ID”证书。
     * CERTS单元包含一个CertType 4 Ed25519“Id->签名”证书。
     * CERTS单元包含一个CertType 6 Ed25519“签名->认证”证书。
     * CERTS单元包含一个CertType 7 "RSA->Ed25519"交叉证书。
     *以上所有X.509证书均在日期之后和日期之前有效;没有X.509或Ed25519证书过期。
     *所有证书均已正确签署。
     *使用ID->签名证书中列出的身份密钥对ID->签名证书进行签名。
     *签名->认证证书使用ID->签名证书中列出的签名密钥进行签名。
     * RSA->Ed25519交叉证书证明Ed25519身份，并使用“ID”证书中列出的RSA身份签名。
     * ID证书中的认证密钥为1024位RSA密钥。
     * RSA ID证书已正确自签名。


   为了验证发起人只有一个RSA身份密钥，响应者必须检查以下内容:

     * CERTS单元包含一个CertType 3“AUTH”证书。
     * CERTS单元包含一个CertType 2“ID”证书。
     *两个证书都有过期后有效和未过期前有效。
     *认证证书中的认证密钥为1024位RSA密钥。
     * ID证书中的认证密钥为1024位RSA密钥。
     * ID证书中的认证密钥用于签署两个证书。
     的密钥正确地签署了认证证书
       ID证书。
     * ID证书已正确自签名。

   检查这些条件不足以验证启动程序是否具有它声明的ID;为此，必须交换下面4.3和4.4中的单元格。


4.3。AUTH_CHALLENGE细胞

   AUTH_CHALLENGE单元格是一个具有以下字段的可变长度单元格:

       挑战(32个八位字节)
       N_Methods[2八位字节)
       方法[2 * N_Methods八位体]

   它从响应程序发送到启动程序。启动器必须忽略单元末尾的意外字节。响应者必须使用强大的RNG或PRNG独立生成每个挑战。

   质询字段是一个随机生成的字符串，作为身份验证的一部分，启动程序必须对其进行签名(散列)。这些方法是响应器将接受的身份验证方法。现在只定义了两种身份验证方法:参见下面的4.4.1和4.4.2。

4.4。验证细胞

   如果启动程序希望进行身份验证，则响应
   带有CERTS单元和身份验证单元的AUTH_CHALLENGE单元。
   CERTS单元就像服务器将发送的那样，只不过发起者不是为任意链接证书发送CertType 1(可能还有CertType 5)证书，而是发送CertType 3(可能还有可能)
   CertType 6) RSA/Ed25519认证密钥的证书。

   这是因为我们允许在TLS链接上使用任何链接密钥类型，但是这里描述的协议只适用于下面4.4.1和4.4.2中描述的特定密钥类型。

   身份验证单元包含以下内容:

        AuthType                               [ 两个八位字节)
        AuthLen                                [ 两个八位字节)
        身份验证                         [ AuthLen八位字节)

   响应器必须忽略身份验证单元末尾的额外字节。可识别的authtype是1和3，将在下面的两部分中进行描述。

   在启动程序对响应程序的CERTS单元中提供的证书进行了验证并对响应程序进行了身份验证之前，不能发送身份验证单元。

4.1.1。链接认证类型1:RSA-SHA256-TLSSecret

   如果AuthType为1(意味着“RSA-SHA256-TLSSecret”)，则
   身份验证单元的身份验证字段包含以下内容:

       类型:字符“AUTH0001”[8个八进制字符]
       CID:发起者RSA1024身份密钥的SHA256散列[32个八位元]
       SID:响应者RSA1024身份密钥的SHA256散列[32个八位元组]
       的所有字节的SHA256散列，作为协商的一部分从响应程序发送到发起者
         AUTH_CHALLENGE细胞;即版本单元格、CERTS单元格、AUTH_CHALLENGE单元格和任何填充单元格。(32个八位字节)
       CLOG:作为到目前为止协商的一部分，从发起者发送到响应者的所有字节的SHA256散列;也就是说,
         版本单元格、CERTS单元格和任何填充单元格。(32个八位字节)
       SCERT:响应方的TLS链接证书的SHA256散列。(32个八位字节)
       TLSSECRETS: SHA256 HMAC，使用TLS主密钥作为秘钥，包含以下内容:
           - client_random，在TLS客户端Hello中发送
           - server_random，在TLS服务器Hello中发送
           - NUL终止的ASCII字符串:“Tor V3握手TLS交叉认证”[32个八进制字符]
       一个24字节的值，由启动程序随机选择。(模仿SSL3的gmt_unix_time字段，旧版本的Tor发送一个8字节的时间戳作为该字段的前8个字节;新的实现不应该这样做)。
       SIG:使用发起者的“Authenticate”密钥的所有前面字段的SHA256散列的签名。(在Tor中，我们一直使用OAEP-MGF1填料;(参见tor-spec.txt章节0.3)[可变长度]

   要检查身份验证单元格，响应器将检查从TYPE到TLSSECRETS的所有字段是否包含它们的惟一正确值，然后验证签名。
   服务器必须忽略RAND字段之后已签名数据中的任何额外字节。

   如果启动程序声称拥有Ed25519标识，响应程序就不能接受此AuthType。
 (没有AuthType 2:它是保留的，但从未实现过。)

10/24/11。链接认证类型3:Ed25519-SHA256-RFC5705。

   如果AuthType为3，即“Ed25519-SHA256-RFC5705”，则
   AuthType单元的Authentication字段如下:

   修改的值和下面的新字段用星号标记。

       类型:字符“AUTH0003”[8个八进制字符]
       CID:发起者RSA1024身份密钥的SHA256散列[32个八位元]
       SID:响应者RSA1024身份密钥的SHA256散列[32个八位元组]
       CID_ED:启动程序的Ed25519身份密钥[32个八位元]
       SID_ED:响应者的Ed25519身份键，或全零。(32个八位字节)
       的所有字节的SHA256散列，作为协商的一部分从响应程序发送到发起者
         AUTH_CHALLENGE细胞;即版本单元格、CERTS单元格、AUTH_CHALLENGE单元格和任何填充单元格。(32个八位字节)
       CLOG:作为到目前为止协商的一部分，从发起者发送到响应者的所有字节的SHA256散列;也就是说,
         版本单元格、CERTS单元格和任何填充单元格。(32个八位字节)
       SCERT:响应方的TLS链接证书的SHA256散列。(32个八位字节)
       TLSSECRETS:输出RFC5705上的导出函数
         TLS会话，使用作为其输入:
          -标签字符串“出口商为TOR TLS客户端绑定AUTH0003”
          -上下文值等于发起者的Ed25519身份密钥。
          -长度是32。(32个八位字节)
       一个24字节的值，由启动程序随机选择。(24个八位字节)
       SIG:使用发起者的所有以前字段的签名
          Ed25519身份验证密钥(在CertType 6的证书中)。

   要检查身份验证单元格，响应器将检查从TYPE到TLSSECRETS的所有字段是否包含它们的惟一正确值，然后验证签名。
   服务器必须忽略RAND字段之后已签名数据中的任何额外字节。

4.5。NETINFO细胞

   如果协商版本2或更高版本，则双方向对方发送a
   NETINFO细胞。单元的有效载荷为:

      时间(时间戳)[4字节]
      其他地址(Other OR's address)[变量]
         类型(地址类型)[1字节]
         ALEN(地址长度)[1字节]
         AVAL (NBO中的地址值)[ALEN字节]
      NMYADDR(这个或的地址数)[1字节]
        NMYADDR时报》:
          类型(地址类型)[1字节]
          ALEN(地址长度)[1字节]
          AVAL(地址值在NBO中))

   可识别的地址类型(ATYPE)有:
 [04] IPv4。[06] IPv6。

   当ATYPE为0x04 (IPv4)时ALEN必须为4，当ATYPE为0x06 (IPv6)时ALEN必须为16。

   时间戳是从Unix时代开始的一个大端无符号整数秒数。实现必须忽略单元末尾的意外字节。

   实现可以使用时间戳值来帮助确定它们的时钟是否偏斜。发起者可能会使用“other OR’s address”来帮助了解他们的联系可能来自哪个地址，如果他们不知道这个地址的话;以及了解同行是否会将当前的连接视为规范。实现不应该无条件地信任这些值，特别是当它们来自非权威机构时，因为另一方可能会谎报看到的时间或IP地址。

   发起者应该使用“this OR's address”来确保他们已经连接到另一个或其规范地址。(见下面5.3.1。)

5. 线路管理

5.1。创建和创建细胞

   用户递增地设置电路，一次一跳。为了创建一个新电路，OPs将一个create /CREATE2单元发送到第一个节点，通过验证握手的前半段;该节点在握手的后半部分用一个CREATED/CREATED2单元响应。为了将电路扩展到第一个跳点，OP发送一个extend /EXTEND2中继单元(参见5.1.2节)，它指示电路中的最后一个节点发送一个CREATE/CREATE2单元来扩展电路。

   有两种类型的CREATE和CREATED单元格:较旧的“CREATE/CREATED”格式，以及较新的“CREATE2/CREATED2”格式。较新的格式可根据设计进行扩展;年长的那个就不是。

   一个CREATE2单元格包含:

       HTYPE(客户端握手类型)[2字节]
       HLEN(客户端握手数据Len)[2字节]
       HDATA(客户端握手数据)

   CREATED2单元格包含:

       HLEN(服务器握手数据Len)[2字节]
       HDATA(服务器握手数据)

   可识别的握手类型有:

       0x0000 TAP——原始的Tor握手;看到5.1.3
       0 x0001保留
       0x0002 ntor——ntor+curve25519+sha256握手;看到5.1.4


   创建单元格的格式如下:

       HDATA(客户机握手数据)[TAP_C_HANDSHAKE_LEN bytes]
 或

       HTAG(客户端握手类型标签)[16字节]
       HDATA(客户机握手数据)[TAP_C_HANDSHAKE_LEN-16字节]

   第一种格式相当于一个HTYPE为‘tap’，长度为TAP_C_HANDSHAKE_LEN的CREATE2单元格。第二种格式是一种将新的握手类型封装到旧的CREATE cell格式以便迁移的方法。请参阅下面的5.1.2中。已识别的HTAG值为:
 ntor——“ntorNTORntorNTOR”

   创建单元格的格式为:

       HDATA(服务器握手数据)[TAP_S_HANDSHAKE_LEN bytes]
 (它相当于长度为TAP_S_HANDSHAKE_LEN的CREATED2单元格。)

   和DH一样，x和y必须随机产生。

   通常，客户机在使用TAP握手时应该使用CREATE，否则应该使用CREATE2。客户机不应该将第二种格式的CREATE单元格(带有握手类型标记的单元格)直接发送到服务器。

   服务器总是用CREATED响应创建成功，用CREATED2响应创建成功。失败时，服务器发送
   破坏电池以破坏电路。
 [CREATE2是由Tor 0.2.4.7-alpha或更高版本处理的。]

5.1.1。在创建单元中选择电路id

   CREATE/CREATE2单元的CircID是任意选择的非零整数，由发送的节点(OP或或)选择
   创建/ CREATE2细胞。在链路协议3或更低的版本中，CircIDs为2字节长;在协议4或更高版本中，CircIDs是4字节长。

   为了防止CircID冲突，当一个节点向另一个节点发送CREATE/CREATE2单元时，它只根据ORs的公共身份密钥从一半的可能值中进行选择。

   在版本3或更低的链路协议中，如果发送节点的键值较低，则选择MSB为0的CircID;否则，它选择a
   CircID的MSB为1。(公钥按模数进行数值比较。)对于协议版本3或更低版本，没有公钥的客户机
   可以选择任何它想要的CircID，因为客户从不需要处理
   创建/ CREATE2细胞。

   在link protocol version 4或更高版本中，启动连接的节点将其MSB设置为1，未启动连接的节点将其MSB设置为0。

   CircID值0是专门为不属于任何电路的单元预留的:CircID 0不能用于电路。不保留其他CircID值，包括0x8000或0x80000000。

5.1.2中。扩展和扩展细胞

   为了扩展现有的电路，客户端发送一个extend或EXTEND2中继单元到电路中的最后一个节点。

   一个EXTEND2单元的中继有效负载包含:

       NSPEC(链接说明符的数量)[1字节]
         NSPEC时报》:
           LSTYPE(链接说明符类型)[1字节]
           LSLEN(链接说明符长度)[1字节]
           LSPEC(链接说明符)[LSLEN字节]
       HTYPE(客户端握手类型)[2字节]
       HLEN(客户端握手数据Len)[2字节]
       HDATA(客户端握手数据)

   链路说明器描述电路中的下一个节点以及如何连接到它。认可说明符是:
 [00] tls -over tcp, IPv4地址
           一个四个字节的IPv4地址加上两个字节的ORPort [01] tls -over tcp, IPv6地址
           一个16字节的IPv6地址加上两个字节的ORPort[02]遗留身份
           一个20字节的SHA1身份指纹。最多只能列出一个。[03] Ed25519身份
           一个32字节的Ed25519身份指纹。最多只能列出一个。

   节点必须忽略未识别的说明符，并且必须接受除“遗留标识”之外的多个说明符实例。

   出于不可区分的目的，实现应该按照以下顺序发送这些链接说明符:[00]、[02]、[03]、[01]。

   扩展中继单元的中继有效载荷包括:

         地址                        [ 4个字节)
         港口                           [ 2字节)
         洋葱皮[TAP_C_HANDSHAKE_LEN bytes]
         身份指纹[HASH_LEN字节]

   “遗留标识”和“标识指纹”字段是
   下一个洋葱路由器的身份(签名)密钥的PKCS#1 ASN1编码的SHA1哈希。(见0.3以上。)“Ed25519标识”字段是目标节点的Ed25519标识键。包括这个关键信息允许扩展或验证它确实连接到正确的目标或，并防止某些中间人攻击。

   扩展的OR必须检查_all_提供的身份密钥(如果它们能识别格式)，并且如果目标或没有证明它拥有任何这样的身份密钥，就不能扩展电路。
   如果只提供了一个身份密钥，但是扩展或(从目录信息)知道另一个，那么OR也应该执行该密钥。

   如果一个扩展或有一个带有给定Ed25519 ID和RSA标识的通道，并且收到了一个Ed25519 ID和一个不同的RSA标识的请求，它不应该尝试建立另一个连接:它应该失败并破坏电路。

   检查继电器身份后，扩展ORs生成
   从EXTEND/EXTEND2单元格的内容创建/CREATE2单元格。
   详见5.3节。

   扩展单元的有效载荷与扩展单元的有效载荷相同
   创建细胞。

   EXTENDED2单元的有效载荷与a单元的有效载荷相同
   CREATED2细胞。
 [在Tor 0.2.4.8-alpha中添加了对EXTEND2/EXTENDED2的支持]

   客户机在发送TAP握手时应该使用EXTEND格式，并且在运行一个版本太老而不支持EXTEND2的Tor的节点处理扩展单元时必须使用它。在其他情况下，客户机应该使用EXTEND2。

   在生成EXTEND2单元时，客户机应该包含目标单元
   只要目标有Ed25519标识，只要目标支持LinkAuth子协议版本“3”。(参见9.2节)。

   当在扩展单元格中编码一个非点击握手时，客户端应该使用“客户端握手类型标签”的格式。

5.1.3。“龙头”握手

   这种握手使用Z_p和RSA中的Diffie-Hellman来计算一组共享密钥，客户机知道这些密钥只与特定的服务器共享，而服务器知道与发送原始握手的人共享(或者根本不与任何人共享)。它不是很快，也不是很好。(参见戈德堡的《Tor的安全性》
   认证协议”)。

   将TAP_C_HANDSHAKE_LEN定义为DH_LEN+KEY_LEN+PK_PAD_LEN。
   将TAP_S_HANDSHAKE_LEN定义为DH_LEN+HASH_LEN。

   创建单元的有效负载是一个“洋葱皮”，它由DH握手数据(也称为g^x)的第一步组成。这个值使用“遗留混合加密”算法(见上面的0.4)加密到服务器的洋葱密钥，给客户端一个握手:

       PK-encrypted:
         填充                        [ PK_PAD_LEN字节)
         对称密钥[KEY_LEN bytes]
         g^x [PK_ENC_LEN-PK_PAD_LEN-KEY_LEN字节]的第一部分
       对称加密:
         g^x [DH_LEN-(PK_ENC_LEN-PK_PAD_LEN-KEY_LEN)字节的第二部分]

   所创建单元的有效负载，或控件的中继有效负载
   扩展单元,包含:

         DH数据(g^y) [DH_LEN bytes]
         派生键数据(KH) [HASH_LEN bytes] <见>下面的5.2

   一旦OP和an OR完成握手，两者现在都可以用普通DH计算g^xy。在计算g^xy之前，双方都需要
   必须验证接收到的g^x或g^y值没有退化;也就是说，它必须严格大于1且严格小于p-1其中p是DH模数。实现不能使用退化键完成握手。实现不能丢弃其他“弱”g^x值。
 (丢弃退化密钥对安全性至关重要;如果没有丢弃坏密钥，攻击者可以用0或1替换OR创建的单元格的g^y，从而创建一个已知的g^xy并模拟OR。丢弃其他密钥可能会让攻击者了解私钥的位。)

   一旦双方都有了g^xy，他们就可以通过5.2.1中的KDF-TOR函数推导出他们共享的电路密钥和“衍生密钥数据”值。

5.1.4。“ntor”握手

   这个握手使用一组DH握手来计算一组共享密钥，客户端知道它只与一个特定的服务器共享，而服务器知道它与发送原始握手的人共享(或者根本不与任何人共享)。这里我们使用“curve25519”组和表示，如D. J. Bernstein在“curve25519: new diffee - hellman speed records”中指定的那样。
 [ntor握手是在Tor 0.2.4.8-alpha中添加的]

   在本节中，定义:

      H(x,t)作为带有消息x和密钥t的HMAC_SHA256。
      H_LENGTH = 32。
      ID_LENGTH = 20。
      G_LENGTH = 32
      id = "ntor-curve25519-sha256-1" t_mac = PROTOID | ":mac" t_key = | ":key_extract" t_verify = PROTOID | ":verify"
      MULT(a,b) =曲线25519点'a'乘以标量'b'。
      G = curve25519的首选基点([9])
      KEYGEN() = curve25519密钥生成算法，返回私有/公共密钥对。m_expand = PROTOID | ":key_expand"
      KEYID (A) =

   要执行握手，客户端需要知道服务器的身份密钥摘要和该服务器的ntor onion密钥(curve25519公钥)。将ntor洋葱键称为“B”。客户端生成一个临时密钥对:
 x, x =注册机()
 并生成客户端握手，内容如下:

       NODEID服务器标识摘要[ID_LENGTH字节]
       KEYID(B) [H_LENGTH bytes]
       CLIENT_PK X [G_LENGTH字节]

   服务器生成一个密钥对y, y = KEYGEN()，并使用其ntor私钥'b'计算:
 secret_input = EXP(X,y) | EXP(X,b) | ID | | X | y | PROTOID
     auth_input =验证| ID | B | Y b| X | "Server"

   服务器的握手回复为:

       SERVER_PK Y [G_LENGTH bytes]
       AUTH H(auth_input, t_mac) [H_LENGTH bytes]

   然后客户端检查Y是否在G^*[参见下面的注释]中，并计算
 secret_input = EXP(Y,x) | EXP(B,x) | ID | | x | Y | PROTOID
     auth_input =验证| ID | B | Y b| X | "Server"

   客户端验证AUTH == H(auth_input, t_mac)。

   双方都检查EXP()操作是否没有产生无穷大点。[注意:如果组是curve25519，这是对检查Y是否属于组成员的适当替代。]

   现在双方都有一个共享的KEY_SEED值。他们使用5.2.2中描述的KDF和标签m_expand将其扩展为Tor中继协议所需的键。

是5.1.5。CREATE_FAST / CREATED_FAST细胞

   当初始化电路的第一跳时，OP已经建立了OR的身份并使用TLS协商了一个密钥。
   因此，OP并不总是需要执行公钥操作来创建电路。在这种情况下，
   OP可能只发送CREATE_FAST单元格，而不是只发送第一个跃点的CREATE单元格。OR用一个CREATED_FAST单元响应，电路就创建好了。

   一个CREATE_FAST单元格包含:

       关键材料(X) [HASH_LEN bytes]

   CREATED_FAST单元格包含:

       关键材料(Y) [HASH_LEN bytes]
       派生关键数据[HASH_LEN bytes](见下面的5.2.1)

   X和Y的值必须随机产生。

   一旦双方都有了X和Y，他们就可以通过5.2.1中的KDF-TOR函数推导出他们共享的电路密钥和“衍生密钥数据”值。

   CREATE_FAST握手在没有必要的时候是不赞成的;迁移由dirl -spec.txt中描述的“usecreatefast”networkstatus参数控制。
 [Tor 0.3.1.1-alpha和以后默认禁用CREATE_FAST。]

5.2。设置电路键

5.2.1。KDF-TOR

   TAP和CREATE_FAST握手和当前隐藏服务协议使用这个键派生函数。它不应该用于新功能。

   如果使用轻拍握手来扩展电路，双方的关键材料都基于K0=g^xy，表示为大端无符号整数。

   如果使用CREATE_FAST，则双方的关键材料都基于
   K0 Y = X |。

   从基本密钥材料K0，他们计算KEY_LEN*2+HASH_LEN*3字节的派生密钥数据为

       K = H (K0 | [00]) | H (K0 | [01]) | H (K0 |[02]) |…

   K形式的第一个HASH_LEN字节KH;下一个HASH_LEN形成前摘要Df;下一个HASH_LEN 41-60来自向后摘要Db;下一个
   KEY_LEN 61-76形式的Kf，以及最终的KEY_LEN形式Kb。K中的多余字节被丢弃。

   在握手响应中使用KH来演示计算共享密钥的知识。Df用于种子完整性检查散列的数据流或从OP,和Db种子完整性检查散列或数据流的相机会Kf用于加密的数据流或从OP,和
   Kb用于加密从OR到OP的数据流。

5.2.2。KDF-RFC5869

   对于较新的KDF需求，Tor使用关键派生函数HKDF from
   RFC5869，用SHA256实例化。(这是由于克劳奇克的一个建筑。)生成的关键材料为:

       K = K_1 | K_2 | K_3 |…

       其中H(x,t)为HMAC_SHA256，值为x，键为t, K_1 = H(m_expand | INT8(1)， KEY_SEED)， K_(i+1) = H(K_i | m_expand | INT8(i+1)， KEY_SEED)， m_expand (i)是任意选择的值，INT8(i)是一个值为“i”的八位体。

   在RFC5869的词汇表中，这是HKDF-SHA256, info == m_expand, salt == t_key, IKM == secret_input。

   当在ntor握手中使用时，第一个HASH_LEN字节形成前向摘要Df;下一个HASH_LEN来自向后摘要数据库;下一个KEY_LEN形式Kf，下一个KEY_LEN形式Kb，最后一个
   DIGEST_LEN字节被用作nonce，用来代替隐藏服务协议中的KH。K中的多余字节被丢弃。

5.3。创建电路

   当通过网络创建电路时，电路创建器(OP)执行以下步骤:

      1. 选择一个洋葱路由器作为结束节点(R_N):
         对于非匿名目录镜像、引入点或服务集合连接，N可以为1。
         对于匿名连接，N应该是3或更多。
         一些终端节点接受流(参见6.1)，其他则是引入点或集合点(参见rend-spec-{v2,v3}.txt)。

      2. 选择(N-1)个洋葱路由器(R_1…R_N-1)组成路径，使路径中没有路由器出现两次。

      3.如果还没有连接到链中的第一个路由器，打开到该路由器的新连接。

      4. 选择在与链中的第一路由器连接上尚未使用的circID;沿着连接发送一个CREATE/CREATE2单元，由第一个洋葱路由器接收。

      5. 等待，直到接收到一个CREATED/CREATED2单元;完成握手并提取前向键Kf_1和后向键Kb_1。

      6. 对于后续的每个洋葱路由器R (R_2到R_N)，将电路扩展到R。

   为了通过单个洋葱路由器R_M扩展电路，OP执行以下步骤:

      1. 创建一个洋葱皮，使用R_M的公共洋葱密钥加密。

      2. 沿电路发送继电器EXTEND/EXTEND2单元中的洋葱皮(见第5.1.2和5.5节)。

      3.当接收到中继扩展/EXTENDED2单元时，验证KH，并计算共享密钥。电路现在已扩展。

   当一个洋葱路由器收到一个扩展中继单元，它发送一个创建单元到下一个洋葱路由器，与封闭的洋葱皮作为它的有效负载。

   当一个洋葱路由器接收到一个EXTEND2中继单元，它发送一个CREATE2单元到下一个洋葱路由器，包含HLEN, HTYPE，和HDATA作为它的有效负载。开始的洋葱路由器选择一些circID还没有在两个洋葱路由器之间的连接。(但参见
   5.1.1以上，关于选择圆环。)

   在特殊情况下，如果EXTEND/EXTEND2单元包含一个遗留标识，或所有0的标识指纹，或要求扩展回发送扩展单元的中继，电路将失败并被拆除。

   Ed25519标识键在EXTEND2单元格中是不需要的，所以应该接受所有的零键。如果扩展继电器从一致性中知道ed25519密钥，它也应该检查该密钥。(参见5.1.2)。

   如果一个扩展单元包含发送扩展单元的继电器的ed25519键，电路将失败并被拆除。

   当一个洋葱路由器接收到一个CREATE/CREATE2单元，如果它已经在给定的连接上与给定的circID有一个电路，它会丢弃这个单元。否则，在接收到CREATE/CREATE2单元后，它将完成指定的握手，并使用CREATED/CREATED2单元进行应答。

   在接收到一个创建的/创建的2单元后，洋葱路由器将它的有效负载封装到一个扩展的/扩展的d2中继单元中(见5.1.2节)，并将该单元发送到电路上。在接收扩展/EXTENDED2中继单元后，OP可以检索握手资料。
 (作为一种优化，OR实现可能会延迟处理onion，直到流量中断允许在不太影响网络延迟的情况下进行处理。)

5.3.1。规范连接

   攻击者可以通过告诉或Alice扩展到某个由攻击者控制的地址X处的或Bob处，对连接发起中间人攻击。攻击者无法读取加密的流量，但是攻击者现在可以计算Alice和Bob之间发送的所有字节数(假设Alice还没有连接到Bob)。

   为了防止这种情况发生，当OR获得扩展请求时，如果ID匹配，它应该使用现有的OR连接，并且满足以下条件:

       - IP匹配请求的IP。
       - OR知道它使用的连接的IP是规范的，因为它被列在NETINFO单元格中。

    ORs不应该检查服务器描述符中列出的ip。
    信任服务器ip使它更容易秘密模拟一个中继，窃取它的密钥。

5.4。拆除电路

   当电路发生不可恢复的错误，或者电路上的所有流都关闭，电路的预期寿命结束时，电路就会被破坏。

   ORs还应该拆除试图创建:

   *流与RELAY_BEGIN，或
   *集合点与ESTABLISH_RENDEZVOUS，结束在第一个跳。让Tor作为单跳代理使用，使得出口节点和集合节点成为更有吸引力的折衷目标。

   ORs可以使用多种方法来检查他们是否是第一跳:

   *如果OR看到用CREATE_FAST创建的电路，OR肯定是电路的第一个跳。
   *如果OR是响应者和发起者:
     未对链接进行身份验证，或
     *通过不一致的密钥认证，则OR可能是电路的第一跳(或通过桥接继电器的电路的第二跳)。

   电路可以被完全拆除，也可以被一跳一跳地拆除。

   为了完全破坏一个电路，一个或或OP发送一个破坏单元到电路上的相邻节点，使用适当的方向的circID。

   在接收到输出的销毁单元后，或释放与相应电路相关联的资源。如果它不是电路的末端，它就会把这个电路的破坏单元发送到下一个或者电路中的另一个。如果节点是电路的末端，那么它会断开所有相关的边缘连接(见6.1节)。

   当一个破坏单元被处理后，OR忽略相应电路的所有数据或破坏单元。

   为了断开部分电路，OP可以发送一个RELAY_TRUNCATE单元信号给给定的或(流ID为零)。或者发送一个破坏单元到电路的下一个节点，然后用a回复OP
   RELAY_TRUNCATED细胞。
 [注:如果OR接收到一个被截断的单元，并且它有任何中继单元仍然在电路上为下一个节点排队，它将放弃它们而不发送它们。这并不被认为是一致的行为，但是在Tor的新版本出现之前，这个问题可能不会得到解决。因此，如果客户端已经通过某个节点发送了中继单元，而且客户端还不确定这些单元是否已经被发送，那么客户端就不应该向运行任何当前版本Tor的节点发送截断单元。

   当电路中的一个连接发生不可恢复的错误时，连接两端的节点应该(如果它们能够的话)按照如下操作:靠近OP的节点应该发送a
   RELAY_TRUNCATED单元格到OP;离OP更远的节点应该在电路中发送一个破坏单元。

   破坏单元的有效载荷包含一个单八位元，描述电路被关闭的原因。类似地，a的数据
   RELAY_TRUNCATED单元格也包含这个单八位“原因”字段。当发送一个截断或破坏单元因为另一个截断或
   破坏单元格时，应传播错误代码。电路的起源总是将这个错误代码设置为0，以避免泄漏它的版本。

   错误代码是:

     0——没有(没有给出原因)
     1——协议(Tor协议违反)
     2——内部(内部错误)
     3——请求(客户端发送截断命令)
     4—休眠(当前不工作;试图节省带宽。)
     5——资源限制(内存、插座或电路id不足)
     6——连接失败(无法到达继电器)
     7——OR_IDENTITY(连接到继电器，但其或标识不符合预期)
     8—CHANNEL_CLOSED(携带此电路的OR连接失效。)
     9—完成(电路因脏或旧已过期。)
    10——超时(电路构建时间过长)
    11—破坏(线路破坏，客户端未截断)
    12——NOSUCHSERVICE(请求未知隐藏服务)

5.5。路由中继细胞

5.5.1。电路标识检查

   当一个节点想要发送一个继电器或RELAY_EARLY单元，它检查单元的circID，并确定相应的电路沿该连接是否仍然打开。如果没有，节点将删除单元。

   当一个节点接收到一个继电器或RELAY_EARLY单元，它检查单元的circID，并确定它是否有相应的电路沿该连接。如果没有，节点将删除单元。

5.5.2。前进的方向

   转发方向是发送CREATE/CREATE2单元格的方向。

5.5.2.1。从原点路由

   当从OP发送一个中继单元时，OP用流密码加密有效负载，如下所示:

      OP发送中继单元:
         因为我= N…1，其中N为目的节点:
            与Kf_I加密。
         将加密的单元传输到节点1。

5.5.2.2。在洋葱路由器转发

   当正向中继单元被OR接收时，它用流密码解密有效负载，如下所示:
 “向前”继电器单元:
         以Kf为键;解密。

   OR然后通过检查下文6.1节中所述的有效负载来决定它是否识别中继单元。如果OR识别了单元，则处理中继单元的内容。
   否则，如果电路继续运行，它将沿着电路传递解密的中继单元。如果电路的或端遇到一个无法识别的中继单元，就发生了错误:或发送一个破坏单元来破坏电路。

   有关更多信息，请参见下面的第6节。

5.5.3。向后方向

   反向方向是相反的方向
   创建/ CREATE2细胞。

5.5.3.1。在洋葱路由器上向后中继

   当OR接收到一个反向中继单元时，它使用流密码加密有效负载，如下所示:
 “向后”继电器单元:
         使用Kb作为密钥;加密。

5.5.3。路由到原点

   当一个中继单元到达一个OP时，OP使用流密码对负载进行解密，如下所示:

         OP从节点1接收中继单元:
            因为我= 1…N，其中N为电路上的最终节点:
                与Kb_I解密。
                如果有效载荷被识别(见6.1节)，则:
                    发送节点是I。
                    停止并处理有效负载。

5.6。处理relay_early细胞

   继电器早期单元被设计用来限制任何电路可以达到的长度。
   当OR接收到RELAY_EARLY单元，并且电路中的下一个节点说链路协议的v2或更晚，OR将该单元作为a中继
   RELAY_EARLY细胞。否则，较老的驱动器将把它作为一个中继单元进行中继。

   如果一个节点在给定的出站电路上接收到超过8个RELAY_EARLY单元，它应该关闭电路。如果它接收到任何入站RELAY_EARLY单元格，则必须立即关闭电路。

   当说到链接协议的v2或更高版本时，客户端只能发送
   RELAY_EARLY单元内的扩展/扩展d2单元。客户端应该发送第一个~8
   不以任何电路的第一跳为目标的中继单元
   也继电器早期单元，以部分隐藏电路长度。
 [从Tor 0.2.3.11-alpha开始，继电器应拒绝任何继电器
   在RELAY_EARLY单元中未接收到扩展/扩展d2单元。]

6. 应用程序连接和流管理

6.1。传递细胞

   在电路中，OP和结束节点使用的内容
   中继包到隧道端到端命令和TCP连接(“流”)横跨电路。端到端命令可以由任意边发起;流由OP发起。

   接收流的终端节点可能是:
   *退出继电器(RELAY_BEGIN，匿名)，
   *目录服务器(RELAY_BEGIN_DIR，匿名或非匿名)，
   *洋葱服务(RELAY_BEGIN，通过一个集合点匿名)。

   每个未加密中继单元的有效载荷包括:

         中继命令[1字节]'已识别'[2字节]
         StreamID                 [ 2字节)
         消化                   [ 4个字节)
         长度                   [ 2字节)
         数据                     [ 长度字节)
         填充[PAYLOAD_LEN - 11长度字节]

   继电器命令是:

         1——RELAY_BEGIN [forward]
         2——RELAY_DATA[向前或向后]
         3——RELAY_END[向前或向后]
         4——RELAY_CONNECTED[向后]
         5——RELAY_SENDME [forward or backward][有时控制]
         6—RELAY_EXTEND [forward][控制]
         7——RELAY_EXTENDED[向后][控制]
         8——RELAY_TRUNCATE [forward][控制]
         9—RELAY_TRUNCATED [backward][控制]
        10—RELAY_DROP[前进或后退][控制]
        11——RELAY_RESOLVE [forward]
        12——relay_resolve [backward]
        13——RELAY_BEGIN_DIR [forward]
        14——RELAY_EXTEND2 [forward] [control]
        15——RELAY_EXTENDED2[向后][控制]

        32 . .40——用于隐蔽服务;看到rend-spec——{v2, v3} . txt。

        41 . .42——用于电路填充;请参阅第3节的paddingspec .txt。

   标记为“正向”的命令只能由电路发起者发送。标记为“向后”的命令只能由电路中的其他节点发送回发起者。标记为either的命令可以由发起者或其他节点发送。

   “已识别”字段用于简单指示单元格仍是加密的。这是一个优化，以避免计算昂贵的消化每个细胞。发送单元格时，未加密的“已识别”必须设置为零。

   当接收和解密单元格时，如果我们是单元格的目标端点，那么“已识别”将始终为零。对于我们应该中继的单元格，“已识别”字段通常是非零的，但在P=2^-16时意外地为零。

   处理传递细胞时,如果“公认”字段在一个解密继电器载荷为零,“消化”字段的前四个字节计算的运行消化所有的字节注定跳的电路或起源于这个跳的电路,分别播种Df或Db(5.2节中获得上图),并包括传递细胞的整个负载(用消化字段设置为0)。注意，这些摘要_do_包括单元格末尾的填充字节，而不仅仅是“Len”之前的填充字节。如果摘要是正确的，就解密的目的而言，计算单元被认为是“可识别的”(参见上面的5.5节)。
 (该摘要不包括来自不在电路的这一跳处开始或结束的中继单元的任何字节。也就是说，它不包括转发的数据。因此，如果'recognized'为零，但摘要不匹配，则不应更新该节点上正在运行的摘要，而应继续转发单元。)

   所有属于同一隧道流的继电器单元具有相同的流ID。流由opl任意选择。任何流都不能有零的StreamID。相反，影响整个电路的继电器单元使用的是零StreamID，而不是某个特定的流
   ——它们在上面的表格中被标记为“[control]”样式的单元格。(Sendme细胞被标记为“有时控制”，因为它们可以包含StreamID或不取决于它们的目的——见
   第7节)。

   中继单元的“长度”字段包含中继有效负载中包含实际有效负载数据的字节数。未加密有效负载的其余部分用填充字节填充。实现处理未加密中继单元格的填充字节，就像处理其他单元格类型的填充字节一样;看到第三节。

   “填充”字段用于使中继单元内容不可预测，以避免某些攻击(见建议289的基本原理)。实现
   应该用4个零值字节填充该字段，然后再加上尽可能多的随机字节。(如果填充的字节少于4个，那么它们都应该被填充为0。

   实现不能依赖于“Padding”字段的内容。

   如果可以识别中继单元，但不能理解中继命令，则必须删除并忽略该单元。不过，它的内容仍然与摘要和流控制窗口有关。

6.2。打开流并传输数据

   打开一个新的匿名的TCP连接,OP选择退出一个开放的电路,可以连接到目的地址,选择任意StreamID尚未使用,电路和构造RELAY_BEGIN细胞负载编码目的主机的地址和端口。有效载荷格式为:

         ADDRPORT(以nul结尾的字符串)
         旗帜(4个字节)

   ADDRPORT由地址| ':' |端口|[00]组成
 其中地址可以是一个DNS主机名，或一个IPv4地址在点四格式，或一个IPv6地址包围方括号;端口是一个十进制整数，范围从1到65535(包括65535)。

   标志值设置了以下一个或多个位，其中“1位”是32位值的LSB，“32位”是MSB。(记住，Tor中的所有值都是big-endian(参见上面的0.1.1)，因此4字节值的MSB是第一个字节的MSB，而4字节值的LSB是最后一个字节的LSB。)
 有点意思
      1——IPv6没问题。我们支持学习IPv6地址和连接到IPv6地址。
      2——IPv4不行。我们不想了解IPv4地址或连接到它们。
      3——首选IPv6。如果同时有IPv4和IPv6地址，我们希望连接到IPv6地址。(默认情况下，我们连接到IPv4地址。)
      4 . .32——保留。当前客户端不能设置这些。服务器
           必须忽略它们。

   在接收到此单元后，出口节点根据需要解析地址，并打开到目标端口的新TCP连接。如果无法解析地址，或无法建立连接，退出节点将使用RELAY_END单元格响应。(见6.3)。
   否则，退出节点将返回一个RELAY_CONNECTED单元，该单元的有效负载为以下格式之一:

       连接到的IPv4地址[4个字节]
       缓存地址的秒数(TTL)[4个八进制]
 或

       四个零值八进制[四个八进制]
       地址类型(6)[1八位元]
       连接到的IPv6地址[16个八进制]
       缓存地址的秒数(TTL)[4个八进制]
 [在0.1.2.0之前的Tor退出节点将TTL字段设置为固定值。后来的版本将TTL设置为从DNS服务器上看到的最后一个值，并在固定的时间间隔后过期它们自己的缓存条目。这可以防止某些攻击。

   一旦建立了连接，在RELAY_DATA单元中，OP和exit节点包流数据，并在接收到这些单元时，将它们的内容回送到相应的TCP流。

   如果退出节点不支持乐观数据(即，它的版本号在0.2.3.1-alpha之前)，那么OP必须等待RELAY_CONNECTED单元才能发送任何数据。如果退出节点支持乐观数据(即其版本号为)
   ，那么OP可以在发送RELAY_BEGIN单元格之后立即发送RELAY_DATA单元格(并且在接收RELAY_CONNECTED或RELAY_END单元格之前)。

   发送到无法识别的流的RELAY_DATA单元格被丢弃。如果退出节点支持乐观数据，那么它在已经看到RELAY_BEGIN但还没有用RELAY_CONNECTED或RELAY_END响应的流上接收的RELAY_DATA单元将被排队。
   如果使用RELAY_CONNECTED成功创建流，则随后立即处理队列;如果使用RELAY_END创建流失败，则删除队列的内容。

   继电器继电器单元是远程假人;在接收到这样的单元时，OR或OP必须删除它。

6.2.1。打开目录流

   如果Tor中继是一个目录服务器，它应该响应
   RELAY_BEGIN_DIR单元格，就好像它收到了一个请求连接到它的目录端口的开始单元格。RELAY_BEGIN_DIR单元格忽略退出策略，因为流是Tor进程的本地流。

   目录服务器可能是:
   *权威目录(RELAY_BEGIN_DIR，通常是非匿名的)，
   *桥接权威目录(RELAY_BEGIN_DIR，匿名)，
   *目录镜像(RELAY_BEGIN_DIR，通常是非匿名的)，
   *洋葱服务目录(RELAY_BEGIN_DIR，匿名)。

   如果Tor中继没有运行目录服务，它应该使用一个REASON_NOTDIRECTORY RELAY_END单元格响应。

   客户端必须为RELAY_BEGIN_DIR单元生成一个全零有效负载，继电器必须忽略该有效负载。

   在对RELAY_BEGIN_DIR单元格的响应中，继电器要么响应a
   RELAY_CONNECTED单元成功，或RELAY_END单元失败。他们
   必须发送RELAY_CONNECTED单元的全零有效负载，而客户端必须忽略该有效负载。
 [RELAY_BEGIN_DIR不支持前Tor 0.1.2.2-alpha;客户
   不应该将其发送到运行较早版本Tor的路由器。

6.3。关闭流

   当一个匿名的TCP连接被关闭，或者一个边缘节点在任何流中遇到错误，它沿着电路发送一个'RELAY_END'单元格(如果可能的话)并立即关闭TCP连接。如果一个边缘节点接收到任何流的'RELAY_END'单元，它将完全关闭TCP连接，并且不再沿着该流的电路发送任何内容。

   RELAY_END单元的有效负载以一个描述流为什么关闭的“原因”字节开始。由于某些原因，它包含额外的数据(取决于原因)。的值是:

       1——REASON_MISC(由于未列出的原因而捕获所有内容)
       2——REASON_RESOLVEFAILED(无法查找主机名)
       3——reason _connectrefuse(远程主机拒绝连接)[*]
       4——REASON_EXITPOLICY(或拒绝连接到主机或端口)
       5——REASON_DESTROY(电路被破坏)
       6——REASON_DONE(匿名TCP连接被关闭)
       7——REASON_TIMEOUT(连接超时，或者连接时超时)
       8——REASON_NOROUTE(尝试联系目的地时路由错误)
       9——REASON_HIBERNATING(或暂时hibernating)
      10—REASON_INTERNAL (OR的内部错误)
      11——REASON_RESOURCELIMIT(或者没有资源来满足请求)
      12——REASON_CONNRESET(连接意外重置)
      13——REASON_TORPROTOCOL(关闭连接时发送，因为
                                   Tor违反协议)。
      14——REASON_NOTDIRECTORY(客户端发送RELAY_BEGIN_DIR到一个非目录中继)


   大多数情况下，格式是:

      原因                       [ 1字节)

   对于REASON_EXITPOLICY，格式为:

      原因                       [ 1字节)
      IPv4或IPv6地址[4字节或16字节]
      TTL                          [ 4个字节)

   OPs和ORs必须接受上述列表之外的原因，因为Tor的未来版本可能会提供更细粒度的原因。

   对于它们发起的流，除了reason _misc之外，函数不应该发送任何原因。
 旧版本的Tor在连接重置时也会发送这个原因。

   —[本节的其余部分描述未实现的功能。]

   因为TCP连接可以是半开的，所以我们遵循一个等价于TCP的FIN/FIN-ACK/ACK协议来关闭流。

   exit(或者onion service)连接的TCP流可以有三种状态:“OPEN”、“DONE_PACKAGING”和“done_delivery”。为了建模转换，我们将“关闭”作为第四种状态，尽管实际上洋葱路由器不会跟踪这种状态下的连接。

   流以“打开”状态开始。当从相应的TCP连接接收到一个'FIN'时，边缘节点沿电路发送一个'RELAY_FIN'单元格，并将其状态更改为'DONE_PACKAGING'。
   在接收到一个'RELAY_FIN'单元格后，一个边缘节点发送一个'FIN'到相应的TCP连接(例如，通过调用shutdown(SHUT_WR))，并将其状态更改为'DONE_DELIVERING'。

   当已经在' done_delivery'中的流接收到'FIN'时，它也会沿着电路发送'RELAY_FIN'，并将其状态更改为'CLOSED'。当已经在'DONE_PACKAGING'中的流接收到'RELAY_FIN'单元格时，它发送一个'FIN'并将其状态更改为'CLOSED'。

   如果边缘节点在任何流上遇到错误，它会发送一个'RELAY_END'单元格(如果可能的话)并立即关闭流。

6.4。远程主机名查找

   要查找与主机名关联的地址，OP发送a
   RELAY_RESOLVE单元格，该单元格包含要用NUL终止字节解析的主机名。(对于反向查找，OP发送一个包含addr内的RELAY_RESOLVE单元格。arpa地址。)OR用a回答
   包含任意数目答案的relay_resolve单元格。每个答案都是这样的:

       类型(1八隅体)
       长度(1八隅体)
       值(不同宽度)
       TTL(4八位字节)“Length”是值字段的长度。“类型”是其中一种:

      0 x00——主机名
      0x04——IPv4地址
      0x06——IPv6地址
      0xF0——错误，瞬态
      0xF1——错误，非瞬态

    如果任何答案有一个类型的“错误”，那么没有其他的答案可以给出。

    “Value”字段编码答案:
        IP地址按网络顺序给出。
        主机名以标准的DNS顺序给出("www.example.com")，而不是以null结尾。
        错误的内容目前被忽略。继电器目前将它设置为字符串“错误解析主机名”，没有终止NUL。实现必须忽略这个值。

    为了向后兼容性，如果有IPv4答案，则必须给出其中一个作为第一个答案。

    RELAY_RESOLVE单元格必须使用非零的distinct streamID;相应的relay_resolve单元格必须使用相同的streamID。在解析名称时，OR实际上不会创建流。

7. 流控制

7.1。链接节流

   每个客户端或中继应该做适当的带宽节流，以保持其用户满意。

   通信器依赖TCP的默认流控制在停止读取时进行回推。

   主线Tor实现使用令牌桶(一个用于读，一个用于写)来限制速率。

   因为0.2.0。x, Tor允许用户为“中继”通信指定额外的一对令牌桶，这样人们就可以部署具有严格速率限制的Tor中继，但也可以使用同一Tor作为客户端。为了避免分区问题，我们在一个给定的或连接上合并这两类流量，并记录上次读取或写入高优先级(非中继)单元的时间。如果时间小于N秒(目前N=30)，我们将给予整个连接高优先级，否则将给予整个连接低优先级。我们还对提供目录信息的连接的读写给予较低的优先级。详情见建议111。

7.2。链接填充

   可以通过沿连接发送padding或VPADDING单元来创建链接padding;“跌落”型继电器单元可用于远程填充。填充、虚填充或删除单元格的有效载荷由填充字节填充。看到第三节。

   如果链接协议是版本5或更高，则根据padding-spec.txt启用链接级填充。在这些连接中，客户端可以使用CELL_PADDING_NEGOTIATE命令来协商padding的使用，其格式如下:

         版本            [ 1字节)
         ito_low_ms [2 bytes]

   目前，只定义该单元的版本0。在其中，命令字段为1(停止填充)或2(开始填充)。对于开始填充命令，可以将指定随机填充超时的高范围和低范围的一对超时值指定为以毫秒为单位的无符号整数值。ito_low_ms字段不能低于nf_ito_low的当前一致参数值(默认值为1500)。ito_high_ms必须大于ito_low_ms。

   有关填充行为的详细信息，请参见paddings -spec.txt。

7.3。电路级流控制

   为了控制电路的带宽使用，每个或保持跟踪两个“窗口”，包括多少中继数据单元被允许发起或愿意消费。

   这两个窗口分别被命名为:package窗口(为传输打包)和deliver窗口(为本地流打包)。

   由于我们的漏管拓扑结构，电路上的每个继电器都有一对窗口，而OP对电路上的每个继电器都有一对窗口。然而，这些窗口不适用于中继单元，而且从未用于流的中继将永远不会减少其窗口，或导致客户端减少窗口。

   每个“窗口”的值最初是基于目录中的一致参数“circwindow”(参见dir-spec.txt)设置的，或者如果没有给出“circwindow”值，则设置为1000个数据单元格。在每个方向上，细胞都不是
   RELAY_DATA单元格不会影响窗口。

   一个OR或OP(取决于流方向)发送一个RELAY_SENDME单元格，以表明当它的交付窗口低于一个完整的增量(100)时，它愿意接收更多的单元格。例如，如果窗口从1000开始，它应该在到达900时发送RELAY_SENDME。

   当OR或OP接收到RELAY_SENDME时，它将其包窗口的值增加100(电路窗口增量)，并继续发送剩余的RELAY_DATA单元格。

   如果包窗口达到0,OR或OP停止读取相应电路上所有流的TCP连接，不再发送
   RELAY_DATA单元格，直到接收到RELAY_SENDME单元格。

   如果交付窗口低于0，则应拆除电路。

   从tor-0.4.1.1-alpha开始，支持经过身份验证的SENDMEs(版本1，见下面)。这意味着OR和OP都需要记住在(触发)RELAY_SENDME之前的单元的滚动摘要。
   如果包窗口达到电路窗口增量(100)的倍数，就可以知道这一点。

   当RELAY_SENDME版本1到达时，它将包含一个必须与所记住的摘要匹配的摘要。这就证明了电路的终点看到了发送的单元。如果无法匹配，则应拆除电路。

   为了确保不可预测性，应该在至少一个字节中添加随机字节
   RELAY_DATA单元格在一个递增窗口内。换句话说，每增加100个单元，至少应该在一个单元中引入随机字节。

7.3.1。SENDME单元格格式

   电路级RELAY_SENDME单元格的StreamID始终为0。

   OR或OP必须遵守这两个一致参数，以便知道发出和接受哪个版本。
 'sendme_emit_min_version':发出的最小版本。'sendme_accept_min_version':接受的最小版本。

   如果接收到的RELAY_SENDME版本低于最低可接受版本，则应关闭电路。

   RELAY_SENDME负载包含以下内容:

      版本(1个字节)
      DATA_LEN(2字节)
      数据(DATA_LEN字节)

   这个版本告诉我们在数据段的长度中期望得到什么
   DATA_LEN以及如何处理它。确认的值是:

      0x00:负载的其余部分应该被忽略。

      0 x01:验证SENDME。数据部分必须包含:

         消化(20个字节)

         如果DATA_LEN值小于20个字节，则应该删除单元并关闭电路。如果值大于20个字节，那么应该读取前20个字节以获得摘要值。

         摘要是紧接在(触发)此RELAY_SENDME之前的RELAY_DATA单元格的滚动摘要值。该值在OR/OP必须记住的前一个单元格的另一端匹配。

   如果版本是不被认可的或低于最低接受版本(从共识中获得)，电路应该被拆除。

7.4。Stream-level流控制

   边缘节点使用RELAY_SENDME单元来实现跨电路的单个连接的端到端流控制。与电路级流控制类似，边缘节点从每个流的单元格窗口(500)开始，并在接收到RELAY_SENDME单元格时将窗口增加一个固定值(50)。当a)窗口<= 450，和b)在该边缘有少于10个单元有效负载需要刷新时，边缘节点将启动RELAY_SENDME单元。

   流级别的RELAY_SENDME单元格通过具有非零来区分
   StreamID。它们仍然是空的;尸体仍然应该被忽略。


8. 处理资源枯竭


8.1。内存耗尽。

   如果RAM变低，OR应该开始破坏电路，直到更多的内存被释放。我们推荐以下算法:

     -设置恢复RAM的阈值为总RAM的10%。

     -根据电路的“陈旧程度”对电路进行排序，“陈旧程度”指的是电路中排队的最老数据的年龄。该数据可以是:

          *等待从该电路的流刷新的字节。

          *等待从创建的连接刷新的字节
            BEGIN_DIR。

          *等待刷新或处理的单元格。

     -虽然我们还没有恢复足够的RAM:

          *释放最陈旧的电路所持有的所有内存，并在该电路的两个方向上发送破坏单元。计算我们恢复的内存量占总数的比例。

9. Subprotocol版本控制

   此部分指定Tor子协议版本控制。它们根据其当前版本号被分解为不同的类型。任何新的版本号都应该添加到这个部分。

   txt详细说明了这些版本的编码方式。参见描述符中的“原型”/“pr”行，以及投票/协商格式中的“推荐-中继-协议”、“要求-中继-协议”、“推荐-客户端协议”和“要求-客户端协议”行。

   当在协商一致中遇到协议列表时，中继和客户端应该遵循以下规则:

      -当一个中继缺少在推荐中继协议中列出的协议时，它应该警告它的操作员该中继已过时。

      -当一个中继缺少在需求中继协议中列出的协议时，它应该如上警告它的操作员。如果共识比软件发布或计划发布的日期更新，就不能尝试加入网络。

      -当客户端缺少在推荐客户端协议中列出的协议时，应该警告用户该客户端已过时。

      -当客户端缺少在required-client协议中列出的协议时，它应该如上警告用户。如果共识比软件发布的日期更新，它就不能连接到网络上。这为僵尸客户端实现了“安全前向关闭”机制。

      -如果客户端或中继有一个缓存的共识，告诉它一个给定的协议是必需的，并且它没有实现该协议，它
        不要试图达成新的共识。

   软件发布日期应该作为发布过程的一部分自动更新，以防止忘记将它们向前推进。如有必要，软件发布日期可以由维护人员手动调整。

   从0.2.9.4-alpha版本开始，我们将推荐和要求的客户端初始需要的协议有:

      Cons=1-2 Desc=1-2 DirCache=1 HSDir=1 HSIntro=3 HSRend=1 Link=4
      LinkAuth = 1 Microdesc = 1 - 2继电器= 2

   对于继电器，我们将要求:

      Cons=1 Desc=1 DirCache=1 HSDir=1 HSIntro=3 HSRend=1 Link=3-4
      LinkAuth = 1 Microdesc = 1继电器= 1 - 2

   对于继电器，我们将另外推荐我们为客户推荐的所有协议。

9.1。“链接”

   “链接”协议是客户端和继电器用来发起、接收或连接以及处理单元或连接的协议。“link”协议版本与那些版本对应1:1。

   只有当两个Tor实例至少有一个共同的链接协议时，它们才能彼此建立连接。

   目前的“链接”版本是:“1”到“5”。更多信息见4.1节。目前所有的Tor版本都支持“1-3”;版本的
   0.2.4.11-alpha和on支持“1-4”;版本从0.3.1.1-alpha和支持“1-5”。最终我们将放弃“1”和“2”。

9.2。“LinkAuth”

   LinkAuth协议对应于v3+链路协议使用的各种身份验证单元。

   当前版本是:
 “1”是上面4.4.1节中描述的RSA链接认证。
 “2”未使用，由提案244保留。
 “3”是上面4.4.2中描述的ed25519链接认证。


9.3。“接力”

   “中继”协议用于处理CREATE/CREATE2单元，以及处理在CREATE/CREATE2单元之后接收到的各种中继单元类型的协议。(除此之外，用于管理引入点和集合点的中继单元分别使用“HSIntro”和“HSRend”协议进行管理。)

   当前版本是:
 “1”——支持TAP密钥交换，具有Tor 0.2.3中的所有特性。
          支持CREATE和CREATED、CREATE_FAST和CREATED_FAST、EXTEND和EXTENDED。
 “2”——支持ntor密钥交换，以及Tor中的所有特性
          0.2.4.19。包括对CREATE2和CREATED2以及的支持
          EXTEND2 EXTENDED2。

          中继=2有限的IPv6支持:
            *在EXTEND2单元中，客户端可能不包括IPv6 ORPorts。
            *中继(和桥)可能不会启动IPv6连接响应扩展d2单元包含IPv6 ORPorts，即使他们配置了一个IPv6 ORPort。

          然而，中继支持接收到IPv6的入站连接
          ORPorts。他们可能会通过认证的IPv6连接扩展电路到其他继电器。
 “3”——继电器支持扩展在IPv6连接响应
          扩展d2单元包含一个IPv6 ORPort。

          网桥可能不会扩展到IPv6，因为它们试图模仿客户端的行为。

          一个成功的IPv6扩展需要:
            扩展中继上的中继子协议版本3(或更高版本)，
            *扩展中继上的IPv6 ORPort，
            *一个用于在EXTEND2单元中接受中继的IPv6 ORPort
            *接收中继上的IPv6 ORPort。(因为不同的tor实例可以有不同的网络视图，所以应该在选择路径时进行这些检查。
          扩展中继在尝试扩展之前，应该只检查本地IPv6信息。)

          当中继接收到一个同时包含IPv4和an的EXTEND2单元时
          与目标中继之间没有现有的认证连接，扩展中继可以在IPv4和IPv4之间选择
          IPv6随机。如果第一个连接失败，扩展中继可能不会尝试其他地址。

          与其他子协议版本的情况一样，无论当前配置如何，tor都声明、推荐或要求支持该协议版本。

          特别是:
            *继电器没有IPv6 ORPort，和
            * tor实例不是继电器，具有以下行为，无论其配置:
            *在描述符(如果它们是中继、网桥或目录权限)中声明对“Relay=3”的支持
            *对建议或要求支持“Relay=3”的共识做出反应。

          这个子协议版本在提议311中描述，并在Tor 0.4.4.1-alpha中实现。

9.4。“HSIntro”

   “HSIntro”协议处理介绍点。
 “3”——支持Tor提案121中的认证
          0.2.1.6-alpha。
 “4”——支持ed25519认证密钥，它是由HS v3协议定义的，是Tor 0.3.0.4-alpha中提议224的一部分。
 "5"——仅在Tor 0.4.2.1-alpha中为洋葱服务版本3支持ESTABLISH_INTRO单元DoS参数扩展。

9.5。“HSRend”

   “HSRend”协议处理集合点。
 “1”——支持Tor 0.0.6中的所有特性。
 “2”——只要在Tor 0.2.9.1-alpha中有20个字节的cookie，就支持任意长度的集合2单元格。

9.6。“HSDir”

   “HSDir”协议是一组隐藏的服务文档类型，它可以被上传到tor中继上，可以被理解，也可以从tor中继上下载，还有一组可用来获取它们的url。
 "1"——支持Tor 0.2.0.10-alpha中的所有特性。
 “2”——支持ed25519盲密匙请求，该请求由HS v3协议定义，是Tor 0.3.0.4-alpha中proposal 224的一部分。

9.7。“DirCache”

   “DirCache”协议是可以通过BEGIN_DIR从目录缓存中下载的一组文档，以及可以获取它们的一组url。(这排除了隐藏服务对象的url。)
 "1"——支持Tor 0.2.4.19中的所有特性。
 “2”——增加了对共识差异的支持。

9.8。“Desc”

   描述描述符中存在或不存在的特征。

   描述符中的大多数特性不需要“Desc”更新——只需要那些将来需要更新的特性。例如，将来客户端需要理解ed25519身份。
 "1"——支持Tor 0.2.4.19中的所有特性。
 “2”——用洋葱键交叉签名，用ed25519身份签名。

9.9。“Microdesc”

   描述微描述符中存在或不存在的特征。

   描述符中的大多数功能都不需要“微型desc”更新——只需要那些将来需要更新的功能。这些或多或少与协商一致的方法相符合。
 “1”——共识方法9到20。
 “2”——一致性方法21(在microdescs中添加ed25519键)。

9.10。“缺点”

   描述协商一致文件中存在或不存在的特征。

   共识文档中的大多数特性都不需要“缺点”更新——只需要那些将来需要更新的特性。

   这些或多或少与协商一致的方法相符合。
 “1”——共识方法9到20。
 “2”——一致性方法21(在microdescs中添加ed25519键)。

9.11。“填充”

   描述继电器的填充能力。
 "1"——[已失效]继电器支持电路级填充。这个版本不能使用，因为它在不支持电路级填充的继电器中也被启用了。Tor版本从Tor -0.4.0.1-alpha到Tor -0.4.1.4-rc。
 “2”——继电器支持HS电路设置填充机(提案302)。
          从Tor -0.4.1.5及以后的Tor版本广告。

9.12。“FlowCtrl”

   描述电路和流级的流控制协议。如果没有公布FlowCtrl，则tor支持未经身份验证的流控制特性(版本0)。
 “1”——支持提案289中的认证电路级发送
          Tor 0.4.1.1-alpha。
